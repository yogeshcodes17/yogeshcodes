<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>Yogesh Codes Blog</title>
        <link>https://yogeshcodes17.github.io/yogeshcodes/blog</link>
        <description>Yogesh Codes Blog</description>
        <lastBuildDate>Wed, 20 Jul 2022 12:48:36 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <item>
            <title><![CDATA[Analyzing the performance of Javascript Methods]]></title>
            <link>https://yogeshcodes17.github.io/yogeshcodes/blog/performance-analyze-javascript-methods</link>
            <guid>/performance-analyze-javascript-methods</guid>
            <pubDate>Wed, 20 Jul 2022 12:48:36 GMT</pubDate>
            <description><![CDATA[Let's discuss the performance of Javascript built-in methods.]]></description>
            <content:encoded><![CDATA[<p>Let&#x27;s discuss the performance of Javascript built-in methods.</p><h2><em>Things we are going to discuss in this blog:</em></h2><ol><li>Understand how objects and arrays work, through the lens of Big O.</li><li>Understand why adding elements to the start is slow.</li><li>Compare and contrast the runtime for arrays and objects, as well as built-in methods</li></ol><h2><strong>Objects</strong></h2><p>Objects are unordered key-value pairs. Means these object values not indexed like arrays. You giving a key name and key-value, it&#x27;s stored that&#x27;s it it will not be indexed. </p><h3><strong>Where can we use Objects?</strong></h3><ol><li>When you don&#x27;t need to order the elements with the index value. </li><li>When you want to access/insert/remove the elements fastly.</li></ol><p>When you accessing the elements means you don&#x27;t need to search through all the elements of the objects like arrays unless you already know what the exact key name!</p><h3><strong>What is the Big O of objects?</strong></h3><ol><li>Insertion =&gt; O(1) - Ex: obj<!-- -->[&quot;name&quot;]<!-- --> = &quot;John&quot;;</li><li>Removal =&gt; O(1)</li><li>Searching =&gt; O(n) - Ex: Object.keys(obj);</li><li>Access =&gt; O(1) - Ex: obj<!-- -->[&quot;name&quot;]<!-- -->;</li></ol><blockquote><p>When you don&#x27;t want to order elements Objects are well performant.</p></blockquote><h3><strong>Big O Object Methods</strong></h3><ul><li>Object.keys -   O(N)</li><li>Object.values -   O(N)</li><li>Object.entries -   O(N)</li><li>hasOwnProperty -   O(1)</li></ul><h2><strong>Arrays</strong></h2><p>Arrays are ordered list. By default, arrays will order the elements with ascending order when inserting anything.</p><p>Ex: let values = [true, {}, [], 2, &quot;awesome&quot;];</p><h3><strong>Where can we use Arrays?</strong></h3><ol><li>When you want to list elements in the order. </li><li>When you want fast access/insertion and removal (with some limitations)</li></ol><h3><strong>What is the Big O of arrays?</strong></h3><ol><li><p>Inserting</p><ul><li>The performance of the arrays depends on how you inserting the value. </li><li>If you insert at the end of the array. The Big O is O(1). Since it&#x27;s not changing the order of the array. <strong>Ex: <!-- -->[3, 4]<!-- -->.push(2)</strong></li><li>If you insert at the beginning of the array. The Big O is O(n). Since it&#x27;s changing the order of the whole array. Changing the order of the whole array means you can say I&#x27;m just inserting the value in arr<!-- -->[0]<!-- -->. But what really happens is the previous value stored in arr<!-- -->[0]<!-- --> will move arr<!-- -->[1]<!-- --> similar to all the values. <strong>Ex: <!-- -->[1, 3, 4]<!-- -->.shift(2)</strong></li></ul></li><li><p>Removal </p></li></ol><ul><li>Same as inserting.</li><li>Remove the end of the array value is O(1). <strong>Ex: <!-- -->[3,4]<!-- -->.pop()</strong></li><li>Remove the beginning value is costliest O(n). <strong>Ex: <!-- -->[3,4]<!-- -->.unShift()</strong></li></ul><ol start="3"><li>Searching </li></ol><ul><li>Searching an element is O(n). Since we should loop through all the elements of the array to search a particular. No matter we found the element at the beginning or middle. Cumulatively we can consider it as an O(n). <strong>Ex: <!-- -->[2,3,4]<!-- -->.find(value =&gt; value === 3)</strong></li></ul><ol start="4"><li>Accessing</li></ol><ul><li>Accessing an element is O(n). You should know the exact index value of the element to access. <strong>Ex: arr<!-- -->[3]</strong></li></ul><p>The basic array operations we are using daily still there are so many operations we not covering those in this blog. </p><p>concat -   O(N)
slice -   O(N)
splice -   O(N)
sort -   O(N * log N)
forEach/map/filter/reduce/etc. -   O(N)</p><blockquote><p>Inserting at the beginning is not as easy as we might think! There are more efficient data structures for that! We&#x27;ll discuss in coming articles. </p></blockquote><p>Thanks for reading. See you in the next blog soon.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Best Problem-Solving Approaches]]></title>
            <link>https://yogeshcodes17.github.io/yogeshcodes/blog/problem-solving-approaches</link>
            <guid>/problem-solving-approaches</guid>
            <pubDate>Wed, 20 Jul 2022 12:48:36 GMT</pubDate>
            <description><![CDATA[Hello developers,]]></description>
            <content:encoded><![CDATA[<p>Hello developers, </p><p>In this post, we&#x27;re going to discuss the problem-solving Approaches and how to come up with the optimum approaches for a problem. I recommend you to refer to this post before you are solving any problem. Whatever I&#x27;m discussing will help you in the longer run. Hope you will enjoy!</p><h2><strong>Outcomes!</strong></h2><ol><li>Will discuss, about what an algorithm is?</li><li>Will discuss, how to devise a plan to solve any problem?</li><li>Will compare and contrast problem-solving patterns including frequency counters, two-pointer problems and divide and conquer</li></ol><h1><strong>Algorithm</strong></h1><p>A process or set of steps to accomplish a certain task. (in simple terms)</p><p>The algorithm will help you to solve a smaller to bigger problem. It&#x27;s a good practice to write an efficient algorithm all the time. So, we need to practice accordingly. </p><h3><strong>How do we improve our algorithmic skill?</strong></h3><p>To improve our skill we need to follow some rules before proceeding any problem.</p><ol><li>We need to plan before solving anything (like plan what data structures to use, what programming technique is suitable for this problem)</li><li>Master common problem-solving patterns (will discuss in this post)</li></ol><h3><strong>Checklist for problem-solving</strong></h3><ol><li>Understand the problem (observe the expectations)</li><li>Explore concrete examples (play around with the sample inputs)</li><li>Break it down into pieces.</li><li>Solve and simplify.</li><li>Look back and refactor the code.</li></ol><h4><strong>Understand the problem</strong></h4><ul><li>Restructure the whole problem in your own words.</li><li>Gather the information about the inputs of the problem.</li><li>Gather the information about the expected outputs for the problem.</li><li>Think about the output and ask yourself is it possible to produce the output with given inputs? and analyse, is the information given to you enough?</li></ul><p>Example: Write a function which takes two numbers and returns their sum.
First I will write in my own words as I understood the problem. After that, I&#x27;ll analyze the given inputs and possible outputs for the same problem. </p><h3><strong>Explore examples</strong>(Test cases)</h3><p>Explore examples means you don&#x27;t need to come up with the working examples for this problem. Instead, come up with examples of inputs, possible outputs and try to understand the problem better. </p><ul><li>Start with simple examples (write it down the simple example inputs)</li><li>Progress with more complex examples (write some bigger user stories).</li><li>Explore examples with empty values</li><li>Explore examples with invalid values.</li></ul><h3><strong>Break It Down</strong></h3><p>Let&#x27;s break the complex bigger problem into smaller steps to accomplish. write down the steps. This will also help to write better code. Because you already know the steps so you&#x27;ll easily break it down into multiple functions for each subproblem and the code will also readable and maintainable. </p><h3><strong>Simplify the problem</strong></h3><ul><li>Find the more difficult part of the problem you are trying to solve. </li><li>Forgot about that part temporarily and concentrate on other parts. </li><li>After completing all the solvable parts go to the complicated part. </li></ul><h3><strong>Refactoring the code</strong></h3><p>while refactoring the code try to convert it to more readable and performant. Comment the code well.
Checklist for refactoring the code:</p><ul><li>Can you check the result?</li><li>Can you derive the result differently?</li><li>Can you understand it at a glance?</li><li>Can you use the result or method for some other problem?</li><li>Can you improve the performance of your solution?</li><li>Can you think of other ways to refactor?</li><li>How have other people solved this problem?</li></ul><p>I won&#x27;t say this is the best approach. The best approach doesn&#x27;t exist. If you have any thoughts feel free to comment below. </p><p>Let&#x27;s master the common problem-solving patterns in the next blog. </p><p>Thanks!</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Problem Solving Patterns]]></title>
            <link>https://yogeshcodes17.github.io/yogeshcodes/blog/problem-solving-patterns</link>
            <guid>/problem-solving-patterns</guid>
            <pubDate>Wed, 20 Jul 2022 12:48:36 GMT</pubDate>
            <description><![CDATA[When talking about the patterns, there will not the best problem-solving patterns it does not exist. Instead, look at all the patterns and choose whichever is best.]]></description>
            <content:encoded><![CDATA[<p>When talking about the patterns, there will not the best problem-solving patterns it does not exist. Instead, look at all the patterns and choose whichever is best. </p><p>Today I pass through some good problem-solving patterns. I would like to share with you all.</p><h2><strong>1. Frequency Counter</strong></h2><p><img src="https://www.electronics-notes.com/images/frequency-counter-aimtti-tf900-01.jpg" alt="Alt text of image"/></p><p>This will not calculate the frequency. This will collect the frequencies of value. It will use Objects/Sets of key and values to store the values. This can often avoid the need for nested loops or O(N^2) operations with arrays/strings.</p><p>Let&#x27;s take an example:</p><ul><li>Write a function called sameValues, which accepts two arrays. The function should return true if every value in the array has its corresponding value squared in the second array. The frequency of values must be the same.</li></ul><p>Sample input/outputs:</p><pre><code class="language-javascript">sameValues([1,2,3], [4,1,9]) // true
sameValues([1,2,3], [1,9]) // false
sameValues([1,2,1], [4,4,1]) // false (must be same frequency)
</code></pre><p>Here is the problem the squarred value not only should be in second array. Instead it should be in same frequency/occurence</p><h3>Standard Solution:</h3><pre><code class="language-javascript">function same(arr1, arr2){
    if(arr1.length !== arr2.length){
        return false;
    }
    for(let i = 0; i &lt; arr1.length; i++){
        let correctIndex = arr2.indexOf(arr1[i] ** 2) // Loop inside a loop
        if(correctIndex === -1) {
            return false;
        }
        arr2.splice(correctIndex,1)
    }
    return true
}

// Time Complexity =&gt; O(N^2)
</code></pre><h3>Optimized solution</h3><pre><code class="language-javascript">function same(arr1, arr2){
    if(arr1.length !== arr2.length){ // If array 1 is not equal to array 2 return false
        return false;
    }
    // Initialize the freqeuncyCounter for both values
    let frequencyCounter1 = {}
    let frequencyCounter2 = {}
    
    // Get array elements one by one and add 1 to it if already exists or else initiate it. 
    for(let val of arr1){
        frequencyCounter1[val] = (frequencyCounter1[val] || 0) + 1
    }

    // Same applicable to array 2
    for(let val of arr2){
        frequencyCounter2[val] = (frequencyCounter2[val] || 0) + 1        
    }

    // Now the important part, we checked each key in frequencyCounter1
    // Squaring the value and check if it exists in frequencyCounter2
    // If not return false
    // And also check the passed key having the same frequency if not return false.
    // If it pass through all the conditions return true.
    for(let key in frequencyCounter1){
        if(!(key ** 2 in frequencyCounter2)){
            return false
        }
        if(frequencyCounter2[key ** 2] !== frequencyCounter1[key]){
            return false
        }
    }
    return true
}

// Time Complexity =&gt; O(n)
</code></pre><p>In this problem, we removed the loop inside the loop instead we created the separate loops and store the values in the object. </p><h2><strong>2. Multiple Pointers</strong></h2><p>Creating pointers or values that correspond to an index or position and move towards the beginning, end or middle based on a certain condition</p><blockquote><p>Very efficient for solving problems with minimal space complexity as well</p></blockquote><h4>Example:</h4><p>Write a function called sumZero which accepts a sorted array of integers. The function should find the first pair where the sum is 0. Return an array that includes both values that sum to zero or undefined if a pair does not exist</p><p><em>Sample Inputs/Outputs</em></p><pre><code class="language-javascript">sumZero([-3,-2,-1,0,1,2,3]) // [-3,3] 
sumZero([-2,0,1,3]) // undefined
sumZero([1,2,3]) // undefined
</code></pre><h3>Standard Solution:</h3><pre><code class="language-javascript">function sumZero(arr){
    for(let i = 0; i &lt; arr.length; i++){
        for(let j = i+1; j &lt; arr.length; j++){ // Loop inside a loop
            if(arr[i] + arr[j] === 0){
                return [arr[i], arr[j]];
            }
        }
    }
}
// Time Complexity =&gt; O(n^2)
</code></pre><h3>Optimized Solution:</h3><pre><code class="language-javascript">function sumZero(arr){
    let left = 0; // Initialize the first pointer with 0th index
    let right = arr.length - 1; // Second pointer to the end of the array
    while(left &lt; right){ // Iterate till the two pointer become same
        let sum = arr[left] + arr[right]; 
        if(sum === 0){ // If sum zero found the values return it.
            return [arr[left], arr[right]];
        } else if(sum &gt; 0){ // Means the right pointer value will not match anymore so we need to decrease our array order. 
            right--;
        } else { // the left pointer value not be found in right pointer value
            left++;
        }
    }
}
</code></pre><h2><strong>3. Sliding Window</strong></h2><ul><li><p>This pattern involves creating a window which can either be an array or number from one position to another</p></li><li><p>All the way from beginning to end it&#x27;s sliding one another. First, it&#x27;ll solve the first set of values and then go to the next set. Will continue till the end.</p></li><li><p>Depending on a certain condition, the window either increases or closes (and a new window is created)</p></li><li><p>Very useful for keeping track of a subset of data in an array/string etc.</p></li></ul><h4><em>Example:</em></h4><p>Write a function called maxSubarraySum which accepts an array of integers and a number called n. The function should calculate the maximum sum of n consecutive elements in the array.</p><p>Sample Inputs:
maxSubarraySum(<!-- -->[1,2,5,2,8,1,5]<!-- -->,2) // 10
maxSubarraySum(<!-- -->[1,2,5,2,8,1,5]<!-- -->,4) // 17
maxSubarraySum(<!-- -->[4,2,1,6]<!-- -->,1) // 6
maxSubarraySum(<!-- -->[4,2,1,6,2]<!-- -->,4) // 13
maxSubarraySum([],4) // null</p><h3>Standard Solution</h3><pre><code class="language-javascript">function maxSubarraySum(arr, num) {
  if ( num &gt; arr.length){
    return null;
  }
  var max = -Infinity;
  for (let i = 0; i &lt; arr.length - num + 1; i ++){
    temp = 0;
    for (let j = 0; j &lt; num; j++){
      temp += arr[i + j];
    }
    if (temp &gt; max) {
      max = temp;
    }
  }
  return max;
}
</code></pre><h3>Optimized solution</h3><pre><code class="language-javascript">function maxSubarraySum(arr, num){
  let maxSum = 0;
  let tempSum = 0;
  if (arr.length &lt; num) return null;
  for (let i = 0; i &lt; num; i++) { // Initiated out first slide with num numbers
    maxSum += arr[i]; // Store the sum on num array values in maxSum
  }
  tempSum = maxSum; // Initiate the tempSum with maxSum value
  for (let i = num; i &lt; arr.length; i++) { // Iterate from where you left before
    tempSum = tempSum - arr[i - num] + arr[i]; // don&#x27;t need to iterate again the num numbers of next slide instead sub the earlier starting value and add next first value.
    maxSum = Math.max(maxSum, tempSum); // Calculate the maximum of two values and asign to maxSum
  }
  return maxSum;
}
</code></pre>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Recursion in daily programming!]]></title>
            <link>https://yogeshcodes17.github.io/yogeshcodes/blog/recursion-daily-practicing</link>
            <guid>/recursion-daily-practicing</guid>
            <pubDate>Wed, 20 Jul 2022 12:48:36 GMT</pubDate>
            <description><![CDATA[We may use recursion in daily programming without knowing.]]></description>
            <content:encoded><![CDATA[<p>We may use recursion in daily programming without knowing.
I will explain what recursion is and where can we use it. Keep reading!</p><h2><strong>What is recursion?</strong></h2><p>In layman terms, when we doing the same task repeatedly we can call it a recursive task. In programming terms, when a function calls a function itself to do the task and it&#x27;s going iteratively to complete. It&#x27;s called recursion.</p><h3>Still confused?</h3><p>Okay, take one example.</p><pre><code class="language-javascript">function findCorrectObject(arr, id) {
   if(arr[arr.length].id === id) {
     return arr[arr.legth];
   } else if(arr.length === 0) {
     return &quot;Not found!&quot;;
   } else {
     arr.pop();
     findCorrectObject(arr, id);
   }
}
findCorrectObject([{id: &quot;3434343&quot;, title: &quot;title 1&quot;}, {id: &quot;45454565&quot;, title: &quot;title 2&quot;}], &quot;3434343&quot;);
</code></pre><p>In this example, we finding the correct element from the array. As you see we called the same function with the required params. This is recursion. It&#x27;ll run till it finds the correct object or the till the array will empty. </p><p>Simple right?</p><h2><strong>Where we can use it?</strong></h2><p>In javascript, recursion taking a huge place. In so many scenarios we can use the recursion. Example: JSON.parse / JSON.stringify</p><p>If you look inside the code of __deep() in lodash library it uses the same recursion. I&#x27;m telling deep cloning means in javascript if assign an object to a variable it&#x27;ll shallow copy it&#x27;ll not a deep copy. This means when you changed the new object created with the existing one it&#x27;ll also change the existing one. </p><p>We can use recursion to solve that problem. </p><p>Here is the code for deep copy of an object! Don&#x27;t get fear about huge code. I&#x27;ll explain what it actually will do. Read the code carefully!</p><pre><code class="language-javascript">function clone(item) {
  if (!item) {
    return item;
  } // null, undefined values check

  var types = [Number, String, Boolean],
    result;

  // normalizing primitives if someone did new String(&#x27;aaa&#x27;), or new Number(&#x27;444&#x27;);
  types.forEach(function(type) {
    if (item instanceof type) {
      result = type(item); // Yeah, we used recursion here! To find the exact primitive
    }
  });
  
  // If the result is still undefined. The item should be an Object or Array
  if (typeof result == &quot;undefined&quot;) { 
    if (Object.prototype.toString.call(item) === &quot;[object Array]&quot;) {
      result = [];
      // If the item is array, we call the same function to deep clone each values. Yes it is recursion.
      item.forEach(function(child, index, array) {
        result[index] = clone(child);
      });
    } else if (typeof item == &quot;object&quot;) {
      // testing that this is DOM
      if (item.nodeType &amp;&amp; typeof item.cloneNode == &quot;function&quot;) {
        result = item.cloneNode(true);
      } else if (!item.prototype) {
        // check that this is a literal
        if (item instanceof Date) {
          result = new Date(item);
        } else {
          // it is an object literal
          result = {};
          for (var i in item) {
            result[i] = clone(item[i]);
          }
        }
      } else {
        // depending what you would like here,
        // just keep the reference, or create new object
        if (false &amp;&amp; item.constructor) {
          // would not advice to do that, reason? Read below
          result = new item.constructor();
        } else {
          result = item;
        }
      }
    } else {
      result = item;
    }
  }

  return result;
}

var copy = clone({
  one: {
    &quot;one-one&quot;: new String(&quot;hello&quot;),
    &quot;one-two&quot;: [&quot;one&quot;, &quot;two&quot;, true, &quot;four&quot;]
  },
  two: document.createElement(&quot;div&quot;),
  three: [
    {
      name: &quot;three-one&quot;,
      number: new Number(&quot;100&quot;),
      obj: new (function() {
        this.name = &quot;Object test&quot;;
      })()
    }
  ]
});
</code></pre><h3><strong>Another Example</strong></h3><p>If you think the previous example is too much, here I took one famous problem to explain recursion. </p><pre><code class="language-javascript">function calculateFactorial(num) {
  if(num === 1) return 1;
  return num * calculateFactorial(num - 1);
}

calculateFactorial(5);
</code></pre><p>In this function, the calculateFactorial will call a total of 5 times to complete the problem. Whenever the calculateFactorial(num - 1) function call it&#x27;ll create the separate function stack and the previous function will wait till the current function resolves. Likewise, the new function will be called in runtime until it returns 1. </p><p>I recently used recursion in my project. I currently working with reactJS. So it&#x27;ll better if explain the real-life scenario. We had one problem, the user need to select the children of the parent in the dropdown. And the children might have another child. Likewise the data will grove. I used this <a href="https://dowjones.github.io/react-dropdown-tree-select/#/story/with-material-design-styles">library</a> to solve the particular problem.</p><p><img src="https://s5.gifyu.com/images/recursion-example.gif"/></p><p>I immensely used recursion inside. Because each object might have another set of object and I need to go through all the phases until I reach the final object without another child. </p><p>Recursion solving so many problems that loops cannot solve. And also the code will be cleaner and optimized. </p><p>Thanks for reading!!</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Solid Principles with React]]></title>
            <link>https://yogeshcodes17.github.io/yogeshcodes/blog/solid-principles-react</link>
            <guid>/solid-principles-react</guid>
            <pubDate>Wed, 20 Jul 2022 12:48:36 GMT</pubDate>
            <description><![CDATA[SOLID is an acronym for the first five object-oriented design (OOD) principles by Robert C. Martin (also known as Uncle Bob).]]></description>
            <content:encoded><![CDATA[<p><em>SOLID</em> is an acronym for the first five object-oriented design (OOD) principles by Robert C. Martin (also known as <a href="http://en.wikipedia.org/wiki/Robert_Cecil_Martin">Uncle Bob</a>).</p><p><strong>The SOLID principles are a set of software design principles that teach us how we can structure our functions and classes to be as robust, maintainable and flexible as possible.</strong></p><h3>The problem:</h3><p>Early days of my career I used to write code that solves the problem fast and never cared about code extensibility and reusability or any design problems.</p><p>I felt like winning at the start but when the codebase grew it becomes a mess. Whenever the user wants a new change to the existing features. It was a nightmare to implement it and push it to production. </p><p>The problem never ends there and I was introducing new bugs by making new changes. The struggle was real. </p><p>I was doing alterations instead of solving the problem for real.</p><p>And then I realised there is a problem which needs to be fixed. Then I did lots of research about how to write clean code. </p><p>If you ever face the above problems you&#x27;re not alone. But we&#x27;re going to sort this out. </p><h3>Solution:</h3><p>The fundamentals of writing good code are following how other people write code without making the codebase a mess. </p><p>Uncle Bob is an experienced person and faced all the problems we faced in his days. And he defined principles to write good code. The SOLID principles are one of them. </p><h3>SOLID stands for:</h3><ul><li><strong>[S</strong> - Single-responsibility Principle]</li><li><strong>[O</strong> - Open-closed Principle]</li><li><strong>[L</strong> - Liskov Substitution Principle]</li><li><strong>[I</strong> - Interface Segregation Principle]</li><li><strong>[D</strong> - Dependency Inversion Principle]</li></ul><h3>If you follow SOLID principles, you can:</h3><ol><li>Write testable code</li><li>Easily extend the old code and implement new features. </li><li>Make fewer bugs</li><li>Understand the code you wrote a few years ago. </li></ol><h2><strong>Single-Responsibility Principle</strong></h2><aside> ðŸ’¡ A class should have one and only one reason to change, meaning that a class should have only one task to do.</aside><p><img src="/images/good-design-bad-design-srp.png" alt="Untitled"/></p><p>Let&#x27;s try to understand this with the Twitter feed. </p><pre><code class="language-jsx">const Home = () =&gt; {
    const [posts, setPosts] = useState([]);
    
    useEffect(() =&gt; {
        fetch(&#x27;/api/posts&#x27;).then(data =&gt; setPosts(data))
    }, []);

    return (
        &lt;div className=&quot;home&quot;&gt;
            &lt;div className=&quot;top-bar&quot;&gt;
                Header....
            &lt;/div&gt;
            &lt;div className=&quot;feed&quot;&gt;
                {posts.map(post =&gt; (
                    &lt;div&gt;
                        {post.title}
                    &lt;/div&gt;
                ))}
            &lt;/div&gt;
            &lt;div className=&quot;footer&quot;&gt;
                Footer
            &lt;/div&gt;
        &lt;/div&gt;
    )
}
</code></pre><p>Here is the Twitter home page and we added header, posts and the footer.  </p><p>And we violated the first principle of SOLID.</p><h3>What?</h3><p>As per the single responsibility principle, the class/module should do only one task. But in our case, it&#x27;s doing multiple tasks. </p><p>Fetching the posts, header, footer data. Rendering the header, post, footer. </p><h3>Let&#x27;s refactor</h3><p>The solution</p><pre><code class="language-jsx">// Extracted the Header component from Home
const Header = ({title, description}) =&gt; {
    return (
        &lt;div&gt;
            {title}
            {description}
        &lt;/div&gt;
    )
}

// Extracted the Post component from Home
const Post = ({title, profile}) =&gt; {
    return (
        
    )
}

// Made custom hook to fetch the posts
const usePosts = () =&gt; {
    const [posts, setPosts] = useState([]);
    
    useEffect(() =&gt; {
        fetch(&#x27;/api/posts&#x27;).then(data =&gt; setPosts(data))
    }, []);
    return posts;
}

// To render the post lists
const PostsList = () =&gt; {
        const posts = usePosts();
}

const Feed = () =&gt; {
    return (
        &lt;&gt;
            &lt;Header /&gt;
            &lt;PostList /&gt;
        &lt;/&gt;
    )

}
</code></pre><p>I reduced LOC for the sake of simplicity. </p><p>As you see the code is already improved a lot and is well readable and extensible. </p><h2><strong>Open-Closed Principle</strong></h2><aside> ðŸ’¡ Objects or entities should be open for extension but closed for modification.</aside><p><img src="/images/good-design-bad-design-ocp.png" alt="Untitled"/></p><p>This means that a class/module should be extendable without modifying the class itself.</p><p>Software systems are designed to allow the behaviour of those systems to be changed by adding new code, rather than changing existing code.</p><p>Let&#x27;s take a look at the <a href="https://popper.js.org/react-popper/">react-popper</a> library.  React Popper is a react wrapper over popperjs library. And it is extensively used for positioning the elements. </p><p>usePopper helps to position the element based on the virtual reference/bounding position</p><pre><code class="language-jsx">const [popperElement, setPopperElement] = React.useState(null);
const { styles, attributes } = usePopper(virtualReference, popperElement);
return (
    &lt;div ref={setPopperElement} style={styles.popper} {...attributes.popper}&gt;
      Tooltip
    &lt;/div&gt;
);
</code></pre><p>The above code will position the tooltip something like below. </p><p><img src="/images/tooltip-example-solid.png" alt="Untitled"/></p><p>Now the problem is the element will stick just like this. Even if you scroll the element will not move above or below since it&#x27;s a virtual reference we have to take care of the scrolling events. And we need to let the element move with the document while scrolling.  </p><h3>Let&#x27;s do it</h3><pre><code class="language-jsx">const usePopperPosition = ({popperElement, popperContainer}) =&gt; {
    const { styles, attributes } = usePopper(virtualReference, popperElement);
    
    const updatePosition = useCallback((): any =&gt; {
    if (isHidden) return;
    if (!popperElement) return;

    virtualReference.getBoundingClientRect = getBoundingClientRect;
    update?.();
  }, [getBoundingClientRect, popperElement, update]);

  useEffect(() =&gt; {
    updatePosition();
  }, [updatePosition]);

  useEffect(() =&gt; {
    popperContainer?.addEventListener(&#x27;scroll&#x27;, updatePosition);
    return () =&gt; popperContainer?.removeEventListener(&#x27;scroll&#x27;, updatePosition);
  }, [updatePosition, popperContainer]);

  return { ...popperResult, update: updatePosition, styles };
}
</code></pre><p>I know the code is very confusing. Let&#x27;s not dig deeper inside the code for now. </p><p>But we extended the usePopper method and created a new hook to add new functionality. </p><p>Yaayy we implemented a new feature without violating the Open-closed principle. </p><h2><strong>Liskov Substitution Principle</strong></h2><aside> ðŸ’¡ Let q(x) be a property provable about objects of x of type T. Then q(y) should be provable for objects y of type S where S is a subtype of T.</aside><p><img src="/images/solid-liskov-example.png" alt="Untitled"/></p><p>The above image is just for understanding the Liskov principle LOL. </p><p>This means that every subclass or derived class should be substitutable for their base or parent class.</p><p>Liskov is probably the most difficult principle to understand. But not anymore.</p><p>Let&#x27;s start by implementing Liskov with the classes.</p><pre><code class="language-jsx">class Bird {
    fly() {
        console.log(&#x27;I can fly&#x27;);
    }
}

class Duck extends Bird {
    quack() {
        console.log(&#x27;I can quack&#x27;);
    }
}

class Penguin extends Bird {
    // Here we violating the Liskow principle by affecting the parent class method.
    fly() {
        throw new Error(&#x27;I can\&#x27;t fly&#x27;);
    }

    swim() {
        console.log(&#x27;I can swim&#x27;);
    }
}

function makeBirdFly(bird) {
    bird.fly();
}

const duck = new Duck();
const penguin = new Penguin();

makeBirdFly(duck);
makeBirdFly(penguin);
</code></pre><p>In the Penguin class, we extended the Bird class and modified the fly behaviour and added swim behaviour since the Penguin cannot fly only can swim.</p><h3>Fixing the problem</h3><pre><code class="language-jsx">class FlyingBird {
    fly() {
        console.log(&#x27;I can fly&#x27;);
    }
}

class SwimmingBird {
    swim() {
        console.log(&#x27;I can swim&#x27;);
    }
}

class Duck extends FlyingBird {
    quack() {
        console.log(&#x27;I can quack&#x27;);
    }
}

class Penguin extends SwimmingBird {

}

function makeBirdFly(bird) {
    bird.fly();
}

function makeBirdSwim(bird) {
    bird.swim();
}

const duck = new Duck();
const penguin = new Penguin();

makeBirdFly(duck);
makeBirdSwim(penguin);
</code></pre><p>We&#x27;re now fixed the problem by separating the classes. And now we can use Penguin class for the replacement of SwimmingBird class as per the Liskov principle. </p><h3>React Example</h3><p>We can follow Liskow while using interfaces in React</p><pre><code class="language-jsx">interface SubmitButtonProps extends HTMLAttributes&lt;HTMLButtonElement&gt; {
  color: string;
}

const SubmitButton = ({ color, ...buttonProps }: SubmitButtonProps) =&gt; {
  return &lt;button style={{backgroundColor: color}} {...buttonProps} /&gt;
}
</code></pre><p>We implemented SubmitButton by inheriting the button element without violating the Liskov.</p><h2><strong>Interface Segregation Principle</strong></h2><p>A client should never be forced to implement an interface that it doesnâ€™t use. So that the <strong>larger interfaces should be split into smaller ones. By doing so, we can ensure that implementing classes only need to be concerned about the methods that are of interest to them.</strong></p><p>We can follow the interface Segregation while typing the component props. </p><p>Example:</p><p>We&#x27;re going to design the table selection behaviour from notion.</p><p><img src="/images/solid-interface-segreg-example.png" alt="Untitled"/></p><p>Bad design</p><pre><code class="language-jsx">// Table selection range from topLeft to bottomRight
// with the current selected cell and the cursorCell(if you navigate through the keyboard)
export interface Range {
  topLeft: Position;
  bottomRight: Position;
    startCell: Position | null;
  cursorCell: Position | null;
}

// We coupled everything into single interface
// In case you only want the range(topLeft, bottomRight) you have to extend
// startCell and cursorCell
</code></pre><p>Good design</p><pre><code class="language-jsx">export interface Range {
  topLeft: Position;
  bottomRight: Position;
}

export interface SelectedPosition {
  startCell: Position | null;
  cursorCell: Position | null;
}

export interface SelectedRange extends Range, SelectedPosition {}

// We segregated everything now it&#x27;s easy to use the interfaces as per we need
// without any overhead.
</code></pre><p><strong>Dependency Inversion Principle</strong></p><aside> ðŸ’¡ Entities must depend on abstractions, not on concretions. It states that the high-level module must not depend on the low-level module, but should depend on abstractions.</aside><p><em>This principle states that we should depend upon abstractions, not concretions.</em></p><p>Example</p><pre><code class="language-jsx">
// Posts component is tightly coupled
const Posts = () =&gt; {
    ...
    async fetchPosts() {
    const posts = await fetch(&#x27;http://api.innofied.com/posts&#x27;);
    this.setState({posts});
  }
    ...
    return (
        &lt;div&gt;
            {posts.map()}
        &lt;/div&gt;
    )
}
</code></pre><pre><code class="language-jsx">// The posts component is now closely coupled and depend on absraction
const Posts = ({fetchPosts}) =&gt; {
    ...
    return (
        &lt;div&gt;
            {posts.map()}
        &lt;/div&gt;
    )
}
</code></pre><p>Conclusion:</p><p>That&#x27;s it for this article. It&#x27;s not necessary to follow the SOLID strictly while developing React applications. But you can consider it as one of the principles/best practices to make the code cleaner.</p>]]></content:encoded>
        </item>
    </channel>
</rss>