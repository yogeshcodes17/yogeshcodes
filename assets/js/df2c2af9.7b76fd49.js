"use strict";(self.webpackChunkwiki_docusaurus=self.webpackChunkwiki_docusaurus||[]).push([[3055],{3905:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>h});var r=t(7294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function s(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?s(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):s(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,r,o=function(e,n){if(null==e)return{};var t,r,o={},s=Object.keys(e);for(r=0;r<s.length;r++)t=s[r],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(r=0;r<s.length;r++)t=s[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var a=r.createContext({}),c=function(e){var n=r.useContext(a),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},u=function(e){var n=c(e.components);return r.createElement(a.Provider,{value:n},e.children)},m={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},p=r.forwardRef((function(e,n){var t=e.components,o=e.mdxType,s=e.originalType,a=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),p=c(t),h=o,d=p["".concat(a,".").concat(h)]||p[h]||m[h]||s;return t?r.createElement(d,i(i({ref:n},u),{},{components:t})):r.createElement(d,i({ref:n},u))}));function h(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var s=t.length,i=new Array(s);i[0]=p;var l={};for(var a in n)hasOwnProperty.call(n,a)&&(l[a]=n[a]);l.originalType=e,l.mdxType="string"==typeof e?e:o,i[1]=l;for(var c=2;c<s;c++)i[c]=t[c];return r.createElement.apply(null,i)}return r.createElement.apply(null,t)}p.displayName="MDXCreateElement"},8689:(e,n,t)=>{t.r(n),t.d(n,{frontMatter:()=>s,contentTitle:()=>i,metadata:()=>l,toc:()=>a,default:()=>u});var r=t(7462),o=(t(7294),t(3905));const s={id:"simple-promise-notes",title:"Simple Promise Implementation"},i=void 0,l={unversionedId:"tech-notes/simple-promise-notes",id:"tech-notes/simple-promise-notes",title:"Simple Promise Implementation",description:"",source:"@site/docs/tech-notes/simple-promise.md",sourceDirName:"tech-notes",slug:"/tech-notes/simple-promise-notes",permalink:"/yogeshcodes/tech-notes/simple-promise-notes",tags:[],version:"current",frontMatter:{id:"simple-promise-notes",title:"Simple Promise Implementation"},sidebar:"docs",previous:{title:"Object Oriented Design",permalink:"/yogeshcodes/tech-notes/objected-oriented-design"},next:{title:"AES-Angular-Springboot-config",permalink:"/yogeshcodes/tech-notes/AES-Angular-Springboot-config"}},a=[],c={toc:a};function u(e){let{components:n,...t}=e;return(0,o.kt)("wrapper",(0,r.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"class PromiseSimple {\n  constructor(executionFunction) {\n    this.promiseChain = [];\n    this.handleError = () => {};\n\n    this.onResolve = this.onResolve.bind(this);\n    this.onReject = this.onReject.bind(this);\n\n    executionFunction(this.onResolve, this.onReject);\n  }\n\n  then(handleSuccess) {\n    this.promiseChain.push(handleSuccess);\n\n    return this;\n  }\n\n  catch(handleError) {\n    this.handleError = handleError;\n\n    return this;\n  }\n\n  onResolve(value) {\n    let storedValue = value;\n\n    try {\n      this.promiseChain.forEach((nextFunction) => {\n        storedValue = nextFunction(storedValue);\n      });\n    } catch (error) {\n      this.promiseChain = [];\n\n      this.onReject(error);\n    }\n  }\n\n  onReject(error) {\n    this.handleError(error);\n  }\n}\n\nfakeApiBackend = () => {\n  const user = {\n    username: 'treyhuffine',\n    favoriteNumber: 42,\n    profile: 'https://gitconnected.com/treyhuffine'\n  };\n\n  // Introduce a randomizer to simulate the possibility of encountering an error\n  if (Math.random() > .05) {\n    return {\n      data: user,\n      statusCode: 200,\n    };\n  } else {\n    const error = {\n      statusCode: 404,\n      message: 'Could not find user',\n      error: 'Not Found',\n    };\n\n    return error;\n  }\n};\n\n// Assume this is your AJAX library.\n// Almost all newer ones return a Promise object.\nconst makeApiCall = () => {\n  return new PromiseSimple((resolve, reject) => {\n    // Use a timeout to simulate the network delay waiting for the response.\n    // This is THE reason you use a promise.\n    // It waits for the API to respond, and after received, it executes code in the `then()` blocks in order.\n    // If it executed this immediately, there would be no data.\n    setTimeout(() => {\n      const apiResponse = fakeApiBackend();\n\n      if (apiResponse.statusCode >= 400) {\n        reject(apiResponse);\n      } else {\n        resolve(apiResponse.data);\n      }\n    }, 5000);\n  });\n};\n\nmakeApiCall()\n  .then((user) => {\n    console.log('In the first .then()');\n\n    return user;\n  })\n  .then((user) => {\n    console.log(`User ${user.username}'s favorite number is ${user.favoriteNumber}`);\n\n    return user;\n  })\n  .then((user) => {\n    console.log('The previous .then() told you the favoriteNumber')\n\n    return user.profile;\n  })\n  .then((profile) => {\n    console.log(`The profile URL is ${profile}`);\n  })\n  .then(() => {\n    console.log('This is the last then()');\n  })\n  .catch((error) => {\n    console.log(error.message);\n  });\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'class Promise {\n  constructor(handler) {\n    this.status = "pending";\n    this.onFulfilledCallbacks = [];\n    this.onRejectedCallbacks = [];\n\n    const resolve = (value) => {\n      if (this.status === "pending") {\n        this.status = "fulfilled";\n        this.value = value;\n        this.onFulfilledCallbacks.forEach((fn) => fn(value));\n      }\n    };\n\n    const reject = (value) => {\n      if (this.status === "pending") {\n        this.status = "rejected";\n        this.value = value;\n        this.onRejectedCallbacks.forEach((fn) => fn(value));\n      }\n    };\n\n    try {\n      handler(resolve, reject);\n    } catch (err) {\n      reject(err);\n    }\n  }\n\n  then(onFulfilled, onRejected) {\n    return new Promise((resolve, reject) => {\n      if (this.status === "pending") {\n        this.onFulfilledCallbacks.push(() => {\n          try {\n            const fulfilledFromLastPromise = onFulfilled(this.value);\n            if (fulfilledFromLastPromise instanceof Promise) {\n              fulfilledFromLastPromise.then(resolve, reject);\n            } else {\n              resolve(fulfilledFromLastPromise);\n            }\n          } catch (err) {\n            reject(err);\n          }\n        });\n        this.onRejectedCallbacks.push(() => {\n          try {\n            const rejectedFromLastPromise = onRejected(this.value);\n            if (rejectedFromLastPromise instanceof Promise) {\n              rejectedFromLastPromise.then(resolve, reject);\n            } else {\n              reject(rejectedFromLastPromise);\n            }\n          } catch (err) {\n            reject(err);\n          }\n        });\n      }\n\n      if (this.status === "fulfilled") {\n        try {\n          const fulfilledFromLastPromise = onFulfilled(this.value);\n          if (fulfilledFromLastPromise instanceof Promise) {\n            fulfilledFromLastPromise.then(resolve, reject);\n          } else {\n            resolve(fulfilledFromLastPromise);\n          }\n        } catch (err) {\n          reject(err);\n        }\n      }\n\n      if (this.status === "rejected") {\n        try {\n          const rejectedFromLastPromise = onRejected(this.value);\n          if (rejectedFromLastPromise instanceof Promise) {\n            rejectedFromLastPromise.then(resolve, reject);\n          } else {\n            reject(rejectedFromLastPromise);\n          }\n        } catch (err) {\n          reject(err);\n        }\n      }\n    });\n  }\n}\n\n')))}u.isMDXComponent=!0}}]);