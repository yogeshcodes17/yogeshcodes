"use strict";(self.webpackChunkwiki_docusaurus=self.webpackChunkwiki_docusaurus||[]).push([[6949],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>h});var o=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,o,i=function(e,t){if(null==e)return{};var n,o,i={},s=Object.keys(e);for(o=0;o<s.length;o++)n=s[o],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(o=0;o<s.length;o++)n=s[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var a=o.createContext({}),p=function(e){var t=o.useContext(a),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},c=function(e){var t=p(e.components);return o.createElement(a.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},u=o.forwardRef((function(e,t){var n=e.components,i=e.mdxType,s=e.originalType,a=e.parentName,c=r(e,["components","mdxType","originalType","parentName"]),u=p(n),h=i,m=u["".concat(a,".").concat(h)]||u[h]||d[h]||s;return n?o.createElement(m,l(l({ref:t},c),{},{components:n})):o.createElement(m,l({ref:t},c))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var s=n.length,l=new Array(s);l[0]=u;var r={};for(var a in t)hasOwnProperty.call(t,a)&&(r[a]=t[a]);r.originalType=e,r.mdxType="string"==typeof e?e:i,l[1]=r;for(var p=2;p<s;p++)l[p]=n[p];return o.createElement.apply(null,l)}return o.createElement.apply(null,n)}u.displayName="MDXCreateElement"},7983:(e,t,n)=>{n.r(t),n.d(t,{frontMatter:()=>s,contentTitle:()=>l,metadata:()=>r,assets:()=>a,toc:()=>p,default:()=>d});var o=n(7462),i=(n(7294),n(3905));const s={title:"Solid Principles with React",tags:["solid","react","javascript","best-practices"]},l="SOLID principles in React",r={permalink:"/yogeshcodes/blog/solid-principles-react",source:"@site/blog/solid-principles-react.md",title:"Solid Principles with React",description:"SOLID is an acronym for the first five object-oriented design (OOD) principles by Robert C. Martin (also known as Uncle Bob).",date:"2022-07-20T12:48:36.000Z",formattedDate:"July 20, 2022",tags:[{label:"solid",permalink:"/yogeshcodes/blog/tags/solid"},{label:"react",permalink:"/yogeshcodes/blog/tags/react"},{label:"javascript",permalink:"/yogeshcodes/blog/tags/javascript"},{label:"best-practices",permalink:"/yogeshcodes/blog/tags/best-practices"}],truncated:!1,authors:[],prevItem:{title:"Recursion in daily programming!",permalink:"/yogeshcodes/blog/recursion-daily-practicing"}},a={authorsImageUrls:[]},p=[{value:"The problem:",id:"the-problem",children:[],level:3},{value:"Solution:",id:"solution",children:[],level:3},{value:"SOLID stands for:",id:"solid-stands-for",children:[],level:3},{value:"If you follow SOLID principles, you can:",id:"if-you-follow-solid-principles-you-can",children:[],level:3},{value:"<strong>Single-Responsibility Principle</strong>",id:"single-responsibility-principle",children:[{value:"What?",id:"what",children:[],level:3},{value:"Let&#39;s refactor",id:"lets-refactor",children:[],level:3}],level:2},{value:"<strong>Open-Closed Principle</strong>",id:"open-closed-principle",children:[{value:"Let&#39;s do it",id:"lets-do-it",children:[],level:3}],level:2},{value:"<strong>Liskov Substitution Principle</strong>",id:"liskov-substitution-principle",children:[{value:"Fixing the problem",id:"fixing-the-problem",children:[],level:3},{value:"React Example",id:"react-example",children:[],level:3}],level:2},{value:"<strong>Interface Segregation Principle</strong>",id:"interface-segregation-principle",children:[],level:2}],c={toc:p};function d(e){let{components:t,...s}=e;return(0,i.kt)("wrapper",(0,o.Z)({},c,s,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"SOLID")," is an acronym for the first five object-oriented design (OOD) principles by Robert C. Martin (also known as ",(0,i.kt)("a",{parentName:"p",href:"http://en.wikipedia.org/wiki/Robert_Cecil_Martin"},"Uncle Bob"),")."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"The SOLID principles are a set of software design principles that teach us how we can structure our functions and classes to be as robust, maintainable and flexible as possible.")),(0,i.kt)("h3",{id:"the-problem"},"The problem:"),(0,i.kt)("p",null,"Early days of my career I used to write code that solves the problem fast and never cared about code extensibility and reusability or any design problems."),(0,i.kt)("p",null,"I felt like winning at the start but when the codebase grew it becomes a mess. Whenever the user wants a new change to the existing features. It was a nightmare to implement it and push it to production. "),(0,i.kt)("p",null,"The problem never ends there and I was introducing new bugs by making new changes. The struggle was real. "),(0,i.kt)("p",null,"I was doing alterations instead of solving the problem for real."),(0,i.kt)("p",null,"And then I realised there is a problem which needs to be fixed. Then I did lots of research about how to write clean code. "),(0,i.kt)("p",null,"If you ever face the above problems you're not alone. But we're going to sort this out. "),(0,i.kt)("h3",{id:"solution"},"Solution:"),(0,i.kt)("p",null,"The fundamentals of writing good code are following how other people write code without making the codebase a mess. "),(0,i.kt)("p",null,"Uncle Bob is an experienced person and faced all the problems we faced in his days. And he defined principles to write good code. The SOLID principles are one of them. "),(0,i.kt)("h3",{id:"solid-stands-for"},"SOLID stands for:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"[S")," - Single-responsibility Principle]"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"[O")," - Open-closed Principle]"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"[L")," - Liskov Substitution Principle]"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"[I")," - Interface Segregation Principle]"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"[D")," - Dependency Inversion Principle]")),(0,i.kt)("h3",{id:"if-you-follow-solid-principles-you-can"},"If you follow SOLID principles, you can:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Write testable code"),(0,i.kt)("li",{parentName:"ol"},"Easily extend the old code and implement new features. "),(0,i.kt)("li",{parentName:"ol"},"Make fewer bugs"),(0,i.kt)("li",{parentName:"ol"},"Understand the code you wrote a few years ago. ")),(0,i.kt)("h2",{id:"single-responsibility-principle"},(0,i.kt)("strong",{parentName:"h2"},"Single-Responsibility Principle")),(0,i.kt)("aside",null,"\ud83d\udca1 A class should have one and only one reason to change, meaning that a class should have only one task to do."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Untitled",src:n(5334).Z})),(0,i.kt)("p",null,"Let's try to understand this with the Twitter feed. "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsx"},'const Home = () => {\n    const [posts, setPosts] = useState([]);\n    \n    useEffect(() => {\n        fetch(\'/api/posts\').then(data => setPosts(data))\n    }, []);\n\n    return (\n        <div className="home">\n            <div className="top-bar">\n                Header....\n            </div>\n            <div className="feed">\n                {posts.map(post => (\n                    <div>\n                        {post.title}\n                    </div>\n                ))}\n            </div>\n            <div className="footer">\n                Footer\n            </div>\n        </div>\n    )\n}\n')),(0,i.kt)("p",null,"Here is the Twitter home page and we added header, posts and the footer.  "),(0,i.kt)("p",null,"And we violated the first principle of SOLID."),(0,i.kt)("h3",{id:"what"},"What?"),(0,i.kt)("p",null,"As per the single responsibility principle, the class/module should do only one task. But in our case, it's doing multiple tasks. "),(0,i.kt)("p",null,"Fetching the posts, header, footer data. Rendering the header, post, footer. "),(0,i.kt)("h3",{id:"lets-refactor"},"Let's refactor"),(0,i.kt)("p",null,"The solution"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsx"},"// Extracted the Header component from Home\nconst Header = ({title, description}) => {\n    return (\n        <div>\n            {title}\n            {description}\n        </div>\n    )\n}\n\n// Extracted the Post component from Home\nconst Post = ({title, profile}) => {\n    return (\n        \n    )\n}\n\n// Made custom hook to fetch the posts\nconst usePosts = () => {\n    const [posts, setPosts] = useState([]);\n    \n    useEffect(() => {\n        fetch('/api/posts').then(data => setPosts(data))\n    }, []);\n    return posts;\n}\n\n// To render the post lists\nconst PostsList = () => {\n        const posts = usePosts();\n}\n\nconst Feed = () => {\n    return (\n        <>\n            <Header />\n            <PostList />\n        </>\n    )\n\n}\n")),(0,i.kt)("p",null,"I reduced LOC for the sake of simplicity. "),(0,i.kt)("p",null,"As you see the code is already improved a lot and is well readable and extensible. "),(0,i.kt)("h2",{id:"open-closed-principle"},(0,i.kt)("strong",{parentName:"h2"},"Open-Closed Principle")),(0,i.kt)("aside",null,"\ud83d\udca1 Objects or entities should be open for extension but closed for modification."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Untitled",src:n(763).Z})),(0,i.kt)("p",null,"This means that a class/module should be extendable without modifying the class itself."),(0,i.kt)("p",null,"Software systems are designed to allow the behaviour of those systems to be changed by adding new code, rather than changing existing code."),(0,i.kt)("p",null,"Let's take a look at the ",(0,i.kt)("a",{parentName:"p",href:"https://popper.js.org/react-popper/"},"react-popper")," library.  React Popper is a react wrapper over popperjs library. And it is extensively used for positioning the elements. "),(0,i.kt)("p",null,"usePopper helps to position the element based on the virtual reference/bounding position"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsx"},"const [popperElement, setPopperElement] = React.useState(null);\nconst { styles, attributes } = usePopper(virtualReference, popperElement);\nreturn (\n    <div ref={setPopperElement} style={styles.popper} {...attributes.popper}>\n      Tooltip\n    </div>\n);\n")),(0,i.kt)("p",null,"The above code will position the tooltip something like below. "),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Untitled",src:n(4409).Z})),(0,i.kt)("p",null,"Now the problem is the element will stick just like this. Even if you scroll the element will not move above or below since it's a virtual reference we have to take care of the scrolling events. And we need to let the element move with the document while scrolling.  "),(0,i.kt)("h3",{id:"lets-do-it"},"Let's do it"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsx"},"const usePopperPosition = ({popperElement, popperContainer}) => {\n    const { styles, attributes } = usePopper(virtualReference, popperElement);\n    \n    const updatePosition = useCallback((): any => {\n    if (isHidden) return;\n    if (!popperElement) return;\n\n    virtualReference.getBoundingClientRect = getBoundingClientRect;\n    update?.();\n  }, [getBoundingClientRect, popperElement, update]);\n\n  useEffect(() => {\n    updatePosition();\n  }, [updatePosition]);\n\n  useEffect(() => {\n    popperContainer?.addEventListener('scroll', updatePosition);\n    return () => popperContainer?.removeEventListener('scroll', updatePosition);\n  }, [updatePosition, popperContainer]);\n\n  return { ...popperResult, update: updatePosition, styles };\n}\n")),(0,i.kt)("p",null,"I know the code is very confusing. Let's not dig deeper inside the code for now. "),(0,i.kt)("p",null,"But we extended the usePopper method and created a new hook to add new functionality. "),(0,i.kt)("p",null,"Yaayy we implemented a new feature without violating the Open-closed principle. "),(0,i.kt)("h2",{id:"liskov-substitution-principle"},(0,i.kt)("strong",{parentName:"h2"},"Liskov Substitution Principle")),(0,i.kt)("aside",null,"\ud83d\udca1 Let q(x) be a property provable about objects of x of type T. Then q(y) should be provable for objects y of type S where S is a subtype of T."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Untitled",src:n(8599).Z})),(0,i.kt)("p",null,"The above image is just for understanding the Liskov principle LOL. "),(0,i.kt)("p",null,"This means that every subclass or derived class should be substitutable for their base or parent class."),(0,i.kt)("p",null,"Liskov is probably the most difficult principle to understand. But not anymore."),(0,i.kt)("p",null,"Let's start by implementing Liskov with the classes."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsx"},"class Bird {\n    fly() {\n        console.log('I can fly');\n    }\n}\n\nclass Duck extends Bird {\n    quack() {\n        console.log('I can quack');\n    }\n}\n\nclass Penguin extends Bird {\n    // Here we violating the Liskow principle by affecting the parent class method.\n    fly() {\n        throw new Error('I can\\'t fly');\n    }\n\n    swim() {\n        console.log('I can swim');\n    }\n}\n\nfunction makeBirdFly(bird) {\n    bird.fly();\n}\n\nconst duck = new Duck();\nconst penguin = new Penguin();\n\nmakeBirdFly(duck);\nmakeBirdFly(penguin);\n")),(0,i.kt)("p",null,"In the Penguin class, we extended the Bird class and modified the fly behaviour and added swim behaviour since the Penguin cannot fly only can swim."),(0,i.kt)("h3",{id:"fixing-the-problem"},"Fixing the problem"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsx"},"class FlyingBird {\n    fly() {\n        console.log('I can fly');\n    }\n}\n\nclass SwimmingBird {\n    swim() {\n        console.log('I can swim');\n    }\n}\n\nclass Duck extends FlyingBird {\n    quack() {\n        console.log('I can quack');\n    }\n}\n\nclass Penguin extends SwimmingBird {\n\n}\n\nfunction makeBirdFly(bird) {\n    bird.fly();\n}\n\nfunction makeBirdSwim(bird) {\n    bird.swim();\n}\n\nconst duck = new Duck();\nconst penguin = new Penguin();\n\nmakeBirdFly(duck);\nmakeBirdSwim(penguin);\n")),(0,i.kt)("p",null,"We're now fixed the problem by separating the classes. And now we can use Penguin class for the replacement of SwimmingBird class as per the Liskov principle. "),(0,i.kt)("h3",{id:"react-example"},"React Example"),(0,i.kt)("p",null,"We can follow Liskow while using interfaces in React"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsx"},"interface SubmitButtonProps extends HTMLAttributes<HTMLButtonElement> {\n  color: string;\n}\n\nconst SubmitButton = ({ color, ...buttonProps }: SubmitButtonProps) => {\n  return <button style={{backgroundColor: color}} {...buttonProps} />\n}\n")),(0,i.kt)("p",null,"We implemented SubmitButton by inheriting the button element without violating the Liskov."),(0,i.kt)("h2",{id:"interface-segregation-principle"},(0,i.kt)("strong",{parentName:"h2"},"Interface Segregation Principle")),(0,i.kt)("p",null,"A client should never be forced to implement an interface that it doesn\u2019t use. So that the ",(0,i.kt)("strong",{parentName:"p"},"larger interfaces should be split into smaller ones. By doing so, we can ensure that implementing classes only need to be concerned about the methods that are of interest to them.")),(0,i.kt)("p",null,"We can follow the interface Segregation while typing the component props. "),(0,i.kt)("p",null,"Example:"),(0,i.kt)("p",null,"We're going to design the table selection behaviour from notion."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Untitled",src:n(4715).Z})),(0,i.kt)("p",null,"Bad design"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsx"},"// Table selection range from topLeft to bottomRight\n// with the current selected cell and the cursorCell(if you navigate through the keyboard)\nexport interface Range {\n  topLeft: Position;\n  bottomRight: Position;\n    startCell: Position | null;\n  cursorCell: Position | null;\n}\n\n// We coupled everything into single interface\n// In case you only want the range(topLeft, bottomRight) you have to extend\n// startCell and cursorCell\n")),(0,i.kt)("p",null,"Good design"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsx"},"export interface Range {\n  topLeft: Position;\n  bottomRight: Position;\n}\n\nexport interface SelectedPosition {\n  startCell: Position | null;\n  cursorCell: Position | null;\n}\n\nexport interface SelectedRange extends Range, SelectedPosition {}\n\n// We segregated everything now it's easy to use the interfaces as per we need\n// without any overhead.\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Dependency Inversion Principle")),(0,i.kt)("aside",null,"\ud83d\udca1 Entities must depend on abstractions, not on concretions. It states that the high-level module must not depend on the low-level module, but should depend on abstractions."),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"This principle states that we should depend upon abstractions, not concretions.")),(0,i.kt)("p",null,"Example"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsx"},"\n// Posts component is tightly coupled\nconst Posts = () => {\n    ...\n    async fetchPosts() {\n    const posts = await fetch('http://api.innofied.com/posts');\n    this.setState({posts});\n  }\n    ...\n    return (\n        <div>\n            {posts.map()}\n        </div>\n    )\n}\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsx"},"// The posts component is now closely coupled and depend on absraction\nconst Posts = ({fetchPosts}) => {\n    ...\n    return (\n        <div>\n            {posts.map()}\n        </div>\n    )\n}\n")),(0,i.kt)("p",null,"Conclusion:"),(0,i.kt)("p",null,"That's it for this article. It's not necessary to follow the SOLID strictly while developing React applications. But you can consider it as one of the principles/best practices to make the code cleaner."))}d.isMDXComponent=!0},763:(e,t,n)=>{n.d(t,{Z:()=>o});const o=n.p+"assets/images/good-design-bad-design-ocp-59f457e0f319f99292391d8136c32034.png"},5334:(e,t,n)=>{n.d(t,{Z:()=>o});const o=n.p+"assets/images/good-design-bad-design-srp-e9c650cd659cf38d123fc421ecd67768.png"},4715:(e,t,n)=>{n.d(t,{Z:()=>o});const o=n.p+"assets/images/solid-interface-segreg-example-62a39f898711dca4124b4c944e83f849.png"},8599:(e,t,n)=>{n.d(t,{Z:()=>o});const o=n.p+"assets/images/solid-liskov-example-74620e07a4f399660a24d89d2c07ceb5.png"},4409:(e,t,n)=>{n.d(t,{Z:()=>o});const o=n.p+"assets/images/tooltip-example-solid-6036a5ada47422220e866afe12af3ddd.png"}}]);