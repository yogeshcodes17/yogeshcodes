"use strict";(self.webpackChunkwiki_docusaurus=self.webpackChunkwiki_docusaurus||[]).push([[8493],{3905:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>d});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},l=Object.keys(e);for(r=0;r<l.length;r++)n=l[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(r=0;r<l.length;r++)n=l[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var u=r.createContext({}),s=function(e){var t=r.useContext(u),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},m=function(e){var t=s(e.components);return r.createElement(u.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},c=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,l=e.originalType,u=e.parentName,m=o(e,["components","mdxType","originalType","parentName"]),c=s(n),d=a,h=c["".concat(u,".").concat(d)]||c[d]||p[d]||l;return n?r.createElement(h,i(i({ref:t},m),{},{components:n})):r.createElement(h,i({ref:t},m))}));function d(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var l=n.length,i=new Array(l);i[0]=c;var o={};for(var u in t)hasOwnProperty.call(t,u)&&(o[u]=t[u]);o.originalType=e,o.mdxType="string"==typeof e?e:a,i[1]=o;for(var s=2;s<l;s++)i[s]=n[s];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}c.displayName="MDXCreateElement"},7260:(e,t,n)=>{n.r(t),n.d(t,{frontMatter:()=>l,contentTitle:()=>i,metadata:()=>o,assets:()=>u,toc:()=>s,default:()=>p});var r=n(7462),a=(n(7294),n(3905));const l={title:"Problem Solving Patterns",tags:["algorithms","javascript"]},i=void 0,o={permalink:"/yogeshcodes/blog/problem-solving-patterns",source:"@site/blog/problem-solving-patterns.md",title:"Problem Solving Patterns",description:"When talking about the patterns, there will not the best problem-solving patterns it does not exist. Instead, look at all the patterns and choose whichever is best.",date:"2022-07-20T12:48:36.000Z",formattedDate:"July 20, 2022",tags:[{label:"algorithms",permalink:"/yogeshcodes/blog/tags/algorithms"},{label:"javascript",permalink:"/yogeshcodes/blog/tags/javascript"}],truncated:!1,authors:[],prevItem:{title:"Best Problem-Solving Approaches",permalink:"/yogeshcodes/blog/problem-solving-approaches"},nextItem:{title:"Recursion in daily programming!",permalink:"/yogeshcodes/blog/recursion-daily-practicing"}},u={authorsImageUrls:[]},s=[{value:"<strong>1. Frequency Counter</strong>",id:"1-frequency-counter",children:[{value:"Standard Solution:",id:"standard-solution",children:[],level:3},{value:"Optimized solution",id:"optimized-solution",children:[],level:3}],level:2},{value:"<strong>2. Multiple Pointers</strong>",id:"2-multiple-pointers",children:[{value:"Example:",id:"example",children:[],level:4},{value:"Standard Solution:",id:"standard-solution-1",children:[],level:3},{value:"Optimized Solution:",id:"optimized-solution-1",children:[],level:3}],level:2},{value:"<strong>3. Sliding Window</strong>",id:"3-sliding-window",children:[{value:"<em>Example:</em>",id:"example-1",children:[],level:4},{value:"Standard Solution",id:"standard-solution-2",children:[],level:3},{value:"Optimized solution",id:"optimized-solution-2",children:[],level:3}],level:2}],m={toc:s};function p(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,r.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"When talking about the patterns, there will not the best problem-solving patterns it does not exist. Instead, look at all the patterns and choose whichever is best. "),(0,a.kt)("p",null,"Today I pass through some good problem-solving patterns. I would like to share with you all."),(0,a.kt)("h2",{id:"1-frequency-counter"},(0,a.kt)("strong",{parentName:"h2"},"1. Frequency Counter")),(0,a.kt)("p",null,(0,a.kt)("img",{parentName:"p",src:"https://www.electronics-notes.com/images/frequency-counter-aimtti-tf900-01.jpg",alt:"Alt text of image"})),(0,a.kt)("p",null,"This will not calculate the frequency. This will collect the frequencies of value. It will use Objects/Sets of key and values to store the values. This can often avoid the need for nested loops or O(N^2) operations with arrays/strings."),(0,a.kt)("p",null,"Let's take an example:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Write a function called sameValues, which accepts two arrays. The function should return true if every value in the array has its corresponding value squared in the second array. The frequency of values must be the same.")),(0,a.kt)("p",null,"Sample input/outputs:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"sameValues([1,2,3], [4,1,9]) // true\nsameValues([1,2,3], [1,9]) // false\nsameValues([1,2,1], [4,4,1]) // false (must be same frequency)\n")),(0,a.kt)("p",null,"Here is the problem the squarred value not only should be in second array. Instead it should be in same frequency/occurence"),(0,a.kt)("h3",{id:"standard-solution"},"Standard Solution:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"function same(arr1, arr2){\n    if(arr1.length !== arr2.length){\n        return false;\n    }\n    for(let i = 0; i < arr1.length; i++){\n        let correctIndex = arr2.indexOf(arr1[i] ** 2) // Loop inside a loop\n        if(correctIndex === -1) {\n            return false;\n        }\n        arr2.splice(correctIndex,1)\n    }\n    return true\n}\n\n// Time Complexity => O(N^2)\n")),(0,a.kt)("h3",{id:"optimized-solution"},"Optimized solution"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"function same(arr1, arr2){\n    if(arr1.length !== arr2.length){ // If array 1 is not equal to array 2 return false\n        return false;\n    }\n    // Initialize the freqeuncyCounter for both values\n    let frequencyCounter1 = {}\n    let frequencyCounter2 = {}\n    \n    // Get array elements one by one and add 1 to it if already exists or else initiate it. \n    for(let val of arr1){\n        frequencyCounter1[val] = (frequencyCounter1[val] || 0) + 1\n    }\n\n    // Same applicable to array 2\n    for(let val of arr2){\n        frequencyCounter2[val] = (frequencyCounter2[val] || 0) + 1        \n    }\n\n    // Now the important part, we checked each key in frequencyCounter1\n    // Squaring the value and check if it exists in frequencyCounter2\n    // If not return false\n    // And also check the passed key having the same frequency if not return false.\n    // If it pass through all the conditions return true.\n    for(let key in frequencyCounter1){\n        if(!(key ** 2 in frequencyCounter2)){\n            return false\n        }\n        if(frequencyCounter2[key ** 2] !== frequencyCounter1[key]){\n            return false\n        }\n    }\n    return true\n}\n\n// Time Complexity => O(n)\n")),(0,a.kt)("p",null,"In this problem, we removed the loop inside the loop instead we created the separate loops and store the values in the object. "),(0,a.kt)("h2",{id:"2-multiple-pointers"},(0,a.kt)("strong",{parentName:"h2"},"2. Multiple Pointers")),(0,a.kt)("p",null,"Creating pointers or values that correspond to an index or position and move towards the beginning, end or middle based on a certain condition"),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"Very efficient for solving problems with minimal space complexity as well")),(0,a.kt)("h4",{id:"example"},"Example:"),(0,a.kt)("p",null,"Write a function called sumZero which accepts a sorted array of integers. The function should find the first pair where the sum is 0. Return an array that includes both values that sum to zero or undefined if a pair does not exist"),(0,a.kt)("p",null,(0,a.kt)("em",{parentName:"p"},"Sample Inputs/Outputs")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"sumZero([-3,-2,-1,0,1,2,3]) // [-3,3] \nsumZero([-2,0,1,3]) // undefined\nsumZero([1,2,3]) // undefined\n")),(0,a.kt)("h3",{id:"standard-solution-1"},"Standard Solution:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"function sumZero(arr){\n    for(let i = 0; i < arr.length; i++){\n        for(let j = i+1; j < arr.length; j++){ // Loop inside a loop\n            if(arr[i] + arr[j] === 0){\n                return [arr[i], arr[j]];\n            }\n        }\n    }\n}\n// Time Complexity => O(n^2)\n")),(0,a.kt)("h3",{id:"optimized-solution-1"},"Optimized Solution:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"function sumZero(arr){\n    let left = 0; // Initialize the first pointer with 0th index\n    let right = arr.length - 1; // Second pointer to the end of the array\n    while(left < right){ // Iterate till the two pointer become same\n        let sum = arr[left] + arr[right]; \n        if(sum === 0){ // If sum zero found the values return it.\n            return [arr[left], arr[right]];\n        } else if(sum > 0){ // Means the right pointer value will not match anymore so we need to decrease our array order. \n            right--;\n        } else { // the left pointer value not be found in right pointer value\n            left++;\n        }\n    }\n}\n")),(0,a.kt)("h2",{id:"3-sliding-window"},(0,a.kt)("strong",{parentName:"h2"},"3. Sliding Window")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"This pattern involves creating a window which can either be an array or number from one position to another")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"All the way from beginning to end it's sliding one another. First, it'll solve the first set of values and then go to the next set. Will continue till the end.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"Depending on a certain condition, the window either increases or closes (and a new window is created)")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"Very useful for keeping track of a subset of data in an array/string etc."))),(0,a.kt)("h4",{id:"example-1"},(0,a.kt)("em",{parentName:"h4"},"Example:")),(0,a.kt)("p",null,"Write a function called maxSubarraySum which accepts an array of integers and a number called n. The function should calculate the maximum sum of n consecutive elements in the array."),(0,a.kt)("p",null,"Sample Inputs:\nmaxSubarraySum(","[1,2,5,2,8,1,5]",",2) // 10\nmaxSubarraySum(","[1,2,5,2,8,1,5]",",4) // 17\nmaxSubarraySum(","[4,2,1,6]",",1) // 6\nmaxSubarraySum(","[4,2,1,6,2]",",4) // 13\nmaxSubarraySum([],4) // null"),(0,a.kt)("h3",{id:"standard-solution-2"},"Standard Solution"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"function maxSubarraySum(arr, num) {\n  if ( num > arr.length){\n    return null;\n  }\n  var max = -Infinity;\n  for (let i = 0; i < arr.length - num + 1; i ++){\n    temp = 0;\n    for (let j = 0; j < num; j++){\n      temp += arr[i + j];\n    }\n    if (temp > max) {\n      max = temp;\n    }\n  }\n  return max;\n}\n")),(0,a.kt)("h3",{id:"optimized-solution-2"},"Optimized solution"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"function maxSubarraySum(arr, num){\n  let maxSum = 0;\n  let tempSum = 0;\n  if (arr.length < num) return null;\n  for (let i = 0; i < num; i++) { // Initiated out first slide with num numbers\n    maxSum += arr[i]; // Store the sum on num array values in maxSum\n  }\n  tempSum = maxSum; // Initiate the tempSum with maxSum value\n  for (let i = num; i < arr.length; i++) { // Iterate from where you left before\n    tempSum = tempSum - arr[i - num] + arr[i]; // don't need to iterate again the num numbers of next slide instead sub the earlier starting value and add next first value.\n    maxSum = Math.max(maxSum, tempSum); // Calculate the maximum of two values and asign to maxSum\n  }\n  return maxSum;\n}\n")))}p.isMDXComponent=!0}}]);