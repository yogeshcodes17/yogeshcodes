"use strict";(self.webpackChunkwiki_docusaurus=self.webpackChunkwiki_docusaurus||[]).push([[6286],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>m});var r=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,i=function(e,t){if(null==e)return{};var n,r,i={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=r.createContext({}),p=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},c=function(e){var t=p(e.components);return r.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},h=r.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),h=p(n),m=i,f=h["".concat(l,".").concat(m)]||h[m]||u[m]||o;return n?r.createElement(f,a(a({ref:t},c),{},{components:n})):r.createElement(f,a({ref:t},c))}));function m(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,a=new Array(o);a[0]=h;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:i,a[1]=s;for(var p=2;p<o;p++)a[p]=n[p];return r.createElement.apply(null,a)}return r.createElement.apply(null,n)}h.displayName="MDXCreateElement"},7211:(e,t,n)=>{n.r(t),n.d(t,{frontMatter:()=>o,contentTitle:()=>a,metadata:()=>s,toc:()=>l,default:()=>c});var r=n(7462),i=(n(7294),n(3905));const o={id:"two-pointer-technique",title:"Two Pointer Technique"},a=void 0,s={unversionedId:"algorithms/two-pointer-technique",id:"algorithms/two-pointer-technique",title:"Two Pointer Technique",description:"Two pointers is really an easy and effective technique that is typically used for searching pairs in a sorted array.",source:"@site/docs/algorithms/two-pointers-technique.md",sourceDirName:"algorithms",slug:"/algorithms/two-pointer-technique",permalink:"/yogeshcodes/algorithms/two-pointer-technique",tags:[],version:"current",frontMatter:{id:"two-pointer-technique",title:"Two Pointer Technique"},sidebar:"docs",previous:{title:"Trees Overview",permalink:"/yogeshcodes/algorithms/trees/trees-overview"},next:{title:"Overview",permalink:"/yogeshcodes/system-design/system-design-overview"}},l=[{value:"Methods:",id:"methods",children:[],level:3}],p={toc:l};function c(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Two pointers is really an easy and effective technique that is typically used for searching pairs in a sorted array.\nGiven a sorted array A (sorted in ascending order), having N integers, find if there exists any pair of elements (A","[i]",", A","[j]",") such that their sum is equal to X."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"A[] = {10, 20, 35, 50, 75, 80}\nX = =70\ni = 0\nj = 5\n\nA[i] + A[j] = 10 + 80 = 90\nSince A[i] + A[j] > X, j--\ni = 0\nj = 4\n\nA[i] + A[j] = 10 + 75 = 85\nSince A[i] + A[j] > X, j--\ni = 0\nj = 3\n\nA[i] + A[j] = 10 + 50 = 60\nSince A[i] + A[j] < X, i++\ni = 1\nj = 3\nm\nA[i] + A[j] = 20 + 50 = 70\nThus this signifies that Pair is Found.\n")),(0,i.kt)("p",null,"Let us do discuss the working of two pointer algorithm in brief which is as follows. The algorithm basically uses the fact that the input array is sorted. We start the sum of extreme values (smallest and largest) and conditionally move both pointers. We move left pointer \u2018i\u2019 when the sum of A","[i]"," and A","[j]"," is less than X. We do not miss any pair because the sum is already smaller than X. Same logic applies for right pointer j."),(0,i.kt)("h3",{id:"methods"},"Methods:"),(0,i.kt)("p",null,"Here we will be proposing a two-pointer algorithm by starting off with the na\xefve approach only in order to showcase the execution of operations going on in both methods and secondary to justify how two-pointer algorithm optimizes code via time complexities across all dynamic programming languages such as C+, Java, Python, and even JavaScript"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Na\xefve Approach using loops")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"function isPairSum(A, N, X)\n{\n    for (var i = 0; i < N-1; i++)\n    {\n        for (var j = i+1; j < N; j++)\n        {\n            // as equal i and j means same element\n            if (i == j)\n                continue;\n\n            // pair exists\n            if (A[i] + A[j] == X)\n                return 1;\n\n            // as the array is sorted\n            if (A[i] + A[j] > X)\n                break;\n        }\n    }\n\n    // No pair found with given sum.\n    return 0;\n}\n")),(0,i.kt)("p",null,"Time Complexity:  O(n2)."),(0,i.kt)("ol",{start:2},(0,i.kt)("li",{parentName:"ol"},"Optimal approach using two pointer algorithm")),(0,i.kt)("p",null,"Now let\u2019s see how the two-pointer technique works. We take two pointers, one representing the first element and other representing the last element of the array, and then we add the values kept at both the pointers. If their sum is smaller than X then we shift the left pointer to right or if their sum is greater than X then we shift the right pointer to left, in order to get closer to the sum. We keep moving the pointers until we get the sum as X. "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"function isPairSum(A, N, X)\n{\n \n    // represents first pointer\n    var i = 0;\n \n    // represents second pointer\n    var j = N - 1;\n \n    while (i < j) {\n \n        // If we find a pair\n        if (A[i] + A[j] == X)\n            return true;\n \n        // If sum of elements at current\n        // pointers is less, we move towards\n        // higher values by doing i++\n        else if (A[i] + A[j] < X)\n            i++;\n \n        // If sum of elements at current\n        // pointers is more, we move towards\n        // lower values by doing j--\n        else\n            j--;\n    }\n    return false;\n}\n")),(0,i.kt)("p",null,"Time Complexity:  O(n)"))}c.isMDXComponent=!0}}]);