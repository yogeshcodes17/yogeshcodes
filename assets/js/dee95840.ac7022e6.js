"use strict";(self.webpackChunkwiki_docusaurus=self.webpackChunkwiki_docusaurus||[]).push([[5151],{9539:e=>{e.exports=JSON.parse('{"blogPosts":[{"id":"/performance-analyze-javascript-methods","metadata":{"permalink":"/yogeshcodes/blog/performance-analyze-javascript-methods","source":"@site/blog/performance-analyze-javascript-methods.md","title":"Analyzing the performance of Javascript Methods","description":"Let\'s discuss the performance of Javascript built-in methods.","date":"2022-07-20T12:48:36.000Z","formattedDate":"July 20, 2022","tags":[{"label":"javascript","permalink":"/yogeshcodes/blog/tags/javascript"},{"label":"optimization","permalink":"/yogeshcodes/blog/tags/optimization"}],"truncated":false,"authors":[],"nextItem":{"title":"Best Problem-Solving Approaches","permalink":"/yogeshcodes/blog/problem-solving-approaches"}},"content":"Let\'s discuss the performance of Javascript built-in methods.\\n\\n\\n## *Things we are going to discuss in this blog:*\\n1. Understand how objects and arrays work, through the lens of Big O.\\n2. Understand why adding elements to the start is slow.\\n3. Compare and contrast the runtime for arrays and objects, as well as built-in methods\\n\\n\\n## **Objects**\\n\\nObjects are unordered key-value pairs. Means these object values not indexed like arrays. You giving a key name and key-value, it\'s stored that\'s it it will not be indexed. \\n\\n### **Where can we use Objects?** \\n1. When you don\'t need to order the elements with the index value. \\n2. When you want to access/insert/remove the elements fastly.\\n\\nWhen you accessing the elements means you don\'t need to search through all the elements of the objects like arrays unless you already know what the exact key name!\\n\\n### **What is the Big O of objects?**\\n1. Insertion => O(1) - Ex: obj[\\"name\\"] = \\"John\\";\\n2. Removal => O(1)\\n3. Searching => O(n) - Ex: Object.keys(obj);\\n4. Access => O(1) - Ex: obj[\\"name\\"];\\n\\n> When you don\'t want to order elements Objects are well performant.\\n\\n### **Big O Object Methods** \\n* Object.keys -   O(N)\\n* Object.values -   O(N)\\n* Object.entries -   O(N)\\n* hasOwnProperty -   O(1)\\n\\n\\n## **Arrays**\\nArrays are ordered list. By default, arrays will order the elements with ascending order when inserting anything.\\n\\nEx: let values = [true, {}, [], 2, \\"awesome\\"];\\n\\n### **Where can we use Arrays?** \\n1. When you want to list elements in the order. \\n2. When you want fast access/insertion and removal (with some limitations)\\n\\n### **What is the Big O of arrays?**\\n1. Inserting\\n     * The performance of the arrays depends on how you inserting the value. \\n     * If you insert at the end of the array. The Big O is O(1). Since it\'s not changing the order of the array. **Ex: [3, 4].push(2)**\\n     * If you insert at the beginning of the array. The Big O is O(n). Since it\'s changing the order of the whole array. Changing the order of the whole array means you can say I\'m just inserting the value in arr[0]. But what really happens is the previous value stored in arr[0] will move arr[1] similar to all the values. **Ex: [1, 3, 4].shift(2)**\\n\\n2. Removal \\n* Same as inserting.\\n* Remove the end of the array value is O(1). **Ex: [3,4].pop()**\\n* Remove the beginning value is costliest O(n). **Ex: [3,4].unShift()**\\n\\n3. Searching \\n* Searching an element is O(n). Since we should loop through all the elements of the array to search a particular. No matter we found the element at the beginning or middle. Cumulatively we can consider it as an O(n). **Ex: [2,3,4].find(value => value === 3)**\\n\\n4. Accessing\\n* Accessing an element is O(n). You should know the exact index value of the element to access. **Ex: arr[3]**\\n\\n\\nThe basic array operations we are using daily still there are so many operations we not covering those in this blog. \\n\\nconcat -   O(N)\\nslice -   O(N)\\nsplice -   O(N)\\nsort -   O(N * log N)\\nforEach/map/filter/reduce/etc. -   O(N)\\n\\n> Inserting at the beginning is not as easy as we might think! There are more efficient data structures for that! We\'ll discuss in coming articles. \\n\\n\\nThanks for reading. See you in the next blog soon."},{"id":"/problem-solving-approaches","metadata":{"permalink":"/yogeshcodes/blog/problem-solving-approaches","source":"@site/blog/problem-solving-approaches.md","title":"Best Problem-Solving Approaches","description":"Hello developers,","date":"2022-07-20T12:48:36.000Z","formattedDate":"July 20, 2022","tags":[{"label":"javascript","permalink":"/yogeshcodes/blog/tags/javascript"},{"label":"algorithms","permalink":"/yogeshcodes/blog/tags/algorithms"},{"label":"problem-solving","permalink":"/yogeshcodes/blog/tags/problem-solving"}],"truncated":false,"authors":[],"prevItem":{"title":"Analyzing the performance of Javascript Methods","permalink":"/yogeshcodes/blog/performance-analyze-javascript-methods"},"nextItem":{"title":"Problem Solving Patterns","permalink":"/yogeshcodes/blog/problem-solving-patterns"}},"content":"Hello developers, \\n\\nIn this post, we\'re going to discuss the problem-solving Approaches and how to come up with the optimum approaches for a problem. I recommend you to refer to this post before you are solving any problem. Whatever I\'m discussing will help you in the longer run. Hope you will enjoy!\\n\\n## **Outcomes!**\\n1. Will discuss, about what an algorithm is?\\n2. Will discuss, how to devise a plan to solve any problem?\\n3. Will compare and contrast problem-solving patterns including frequency counters, two-pointer problems and divide and conquer\\n\\n# **Algorithm** \\n\\nA process or set of steps to accomplish a certain task. (in simple terms)\\n\\nThe algorithm will help you to solve a smaller to bigger problem. It\'s a good practice to write an efficient algorithm all the time. So, we need to practice accordingly. \\n\\n\\n### **How do we improve our algorithmic skill?**\\nTo improve our skill we need to follow some rules before proceeding any problem.\\n1. We need to plan before solving anything (like plan what data structures to use, what programming technique is suitable for this problem)\\n2. Master common problem-solving patterns (will discuss in this post)\\n\\n\\n### **Checklist for problem-solving** \\n1. Understand the problem (observe the expectations)\\n2. Explore concrete examples (play around with the sample inputs)\\n3. Break it down into pieces.\\n4. Solve and simplify.\\n5. Look back and refactor the code.\\n\\n#### **Understand the problem**\\n* Restructure the whole problem in your own words.\\n* Gather the information about the inputs of the problem.\\n* Gather the information about the expected outputs for the problem.\\n* Think about the output and ask yourself is it possible to produce the output with given inputs? and analyse, is the information given to you enough?\\n\\nExample: Write a function which takes two numbers and returns their sum.\\nFirst I will write in my own words as I understood the problem. After that, I\'ll analyze the given inputs and possible outputs for the same problem. \\n\\n### **Explore examples**(Test cases)\\nExplore examples means you don\'t need to come up with the working examples for this problem. Instead, come up with examples of inputs, possible outputs and try to understand the problem better. \\n* Start with simple examples (write it down the simple example inputs)\\n* Progress with more complex examples (write some bigger user stories).\\n* Explore examples with empty values\\n* Explore examples with invalid values.\\n\\n\\n### **Break It Down**\\nLet\'s break the complex bigger problem into smaller steps to accomplish. write down the steps. This will also help to write better code. Because you already know the steps so you\'ll easily break it down into multiple functions for each subproblem and the code will also readable and maintainable. \\n\\n### **Simplify the problem**\\n* Find the more difficult part of the problem you are trying to solve. \\n* Forgot about that part temporarily and concentrate on other parts. \\n* After completing all the solvable parts go to the complicated part. \\n\\n### **Refactoring the code**\\nwhile refactoring the code try to convert it to more readable and performant. Comment the code well.\\nChecklist for refactoring the code:\\n* Can you check the result?\\n* Can you derive the result differently?\\n* Can you understand it at a glance?\\n* Can you use the result or method for some other problem?\\n* Can you improve the performance of your solution?\\n* Can you think of other ways to refactor?\\n* How have other people solved this problem?\\n\\nI won\'t say this is the best approach. The best approach doesn\'t exist. If you have any thoughts feel free to comment below. \\n\\nLet\'s master the common problem-solving patterns in the next blog. \\n\\n\\nThanks!"},{"id":"/problem-solving-patterns","metadata":{"permalink":"/yogeshcodes/blog/problem-solving-patterns","source":"@site/blog/problem-solving-patterns.md","title":"Problem Solving Patterns","description":"When talking about the patterns, there will not the best problem-solving patterns it does not exist. Instead, look at all the patterns and choose whichever is best.","date":"2022-07-20T12:48:36.000Z","formattedDate":"July 20, 2022","tags":[{"label":"algorithms","permalink":"/yogeshcodes/blog/tags/algorithms"},{"label":"javascript","permalink":"/yogeshcodes/blog/tags/javascript"}],"truncated":false,"authors":[],"prevItem":{"title":"Best Problem-Solving Approaches","permalink":"/yogeshcodes/blog/problem-solving-approaches"},"nextItem":{"title":"Recursion in daily programming!","permalink":"/yogeshcodes/blog/recursion-daily-practicing"}},"content":"When talking about the patterns, there will not the best problem-solving patterns it does not exist. Instead, look at all the patterns and choose whichever is best. \\n\\nToday I pass through some good problem-solving patterns. I would like to share with you all.\\n\\n\\n## **1. Frequency Counter**\\n\\n![Alt text of image](https://www.electronics-notes.com/images/frequency-counter-aimtti-tf900-01.jpg)\\n\\nThis will not calculate the frequency. This will collect the frequencies of value. It will use Objects/Sets of key and values to store the values. This can often avoid the need for nested loops or O(N^2) operations with arrays/strings.\\n\\nLet\'s take an example:\\n\\n* Write a function called sameValues, which accepts two arrays. The function should return true if every value in the array has its corresponding value squared in the second array. The frequency of values must be the same.\\n\\nSample input/outputs:\\n\\n```javascript\\nsameValues([1,2,3], [4,1,9]) // true\\nsameValues([1,2,3], [1,9]) // false\\nsameValues([1,2,1], [4,4,1]) // false (must be same frequency)\\n```\\nHere is the problem the squarred value not only should be in second array. Instead it should be in same frequency/occurence\\n\\n### Standard Solution: \\n\\n```javascript \\nfunction same(arr1, arr2){\\n    if(arr1.length !== arr2.length){\\n        return false;\\n    }\\n    for(let i = 0; i < arr1.length; i++){\\n        let correctIndex = arr2.indexOf(arr1[i] ** 2) // Loop inside a loop\\n        if(correctIndex === -1) {\\n            return false;\\n        }\\n        arr2.splice(correctIndex,1)\\n    }\\n    return true\\n}\\n\\n// Time Complexity => O(N^2)\\n```\\n\\n### Optimized solution\\n```javascript \\nfunction same(arr1, arr2){\\n    if(arr1.length !== arr2.length){ // If array 1 is not equal to array 2 return false\\n        return false;\\n    }\\n    // Initialize the freqeuncyCounter for both values\\n    let frequencyCounter1 = {}\\n    let frequencyCounter2 = {}\\n    \\n    // Get array elements one by one and add 1 to it if already exists or else initiate it. \\n    for(let val of arr1){\\n        frequencyCounter1[val] = (frequencyCounter1[val] || 0) + 1\\n    }\\n\\n    // Same applicable to array 2\\n    for(let val of arr2){\\n        frequencyCounter2[val] = (frequencyCounter2[val] || 0) + 1        \\n    }\\n\\n    // Now the important part, we checked each key in frequencyCounter1\\n    // Squaring the value and check if it exists in frequencyCounter2\\n    // If not return false\\n    // And also check the passed key having the same frequency if not return false.\\n    // If it pass through all the conditions return true.\\n    for(let key in frequencyCounter1){\\n        if(!(key ** 2 in frequencyCounter2)){\\n            return false\\n        }\\n        if(frequencyCounter2[key ** 2] !== frequencyCounter1[key]){\\n            return false\\n        }\\n    }\\n    return true\\n}\\n\\n// Time Complexity => O(n)\\n```\\nIn this problem, we removed the loop inside the loop instead we created the separate loops and store the values in the object. \\n\\n\\n## **2. Multiple Pointers**\\n\\nCreating pointers or values that correspond to an index or position and move towards the beginning, end or middle based on a certain condition\\n\\n> Very efficient for solving problems with minimal space complexity as well\\n\\n#### Example: \\nWrite a function called sumZero which accepts a sorted array of integers. The function should find the first pair where the sum is 0. Return an array that includes both values that sum to zero or undefined if a pair does not exist\\n\\n*Sample Inputs/Outputs*\\n```javascript \\nsumZero([-3,-2,-1,0,1,2,3]) // [-3,3] \\nsumZero([-2,0,1,3]) // undefined\\nsumZero([1,2,3]) // undefined\\n```\\n\\n### Standard Solution:\\n```javascript\\nfunction sumZero(arr){\\n    for(let i = 0; i < arr.length; i++){\\n        for(let j = i+1; j < arr.length; j++){ // Loop inside a loop\\n            if(arr[i] + arr[j] === 0){\\n                return [arr[i], arr[j]];\\n            }\\n        }\\n    }\\n}\\n// Time Complexity => O(n^2)\\n```\\n\\n### Optimized Solution:\\n```javascript\\nfunction sumZero(arr){\\n    let left = 0; // Initialize the first pointer with 0th index\\n    let right = arr.length - 1; // Second pointer to the end of the array\\n    while(left < right){ // Iterate till the two pointer become same\\n        let sum = arr[left] + arr[right]; \\n        if(sum === 0){ // If sum zero found the values return it.\\n            return [arr[left], arr[right]];\\n        } else if(sum > 0){ // Means the right pointer value will not match anymore so we need to decrease our array order. \\n            right--;\\n        } else { // the left pointer value not be found in right pointer value\\n            left++;\\n        }\\n    }\\n}\\n```\\n\\n## **3. Sliding Window**\\n* This pattern involves creating a window which can either be an array or number from one position to another\\n\\n* All the way from beginning to end it\'s sliding one another. First, it\'ll solve the first set of values and then go to the next set. Will continue till the end.\\n\\n* Depending on a certain condition, the window either increases or closes (and a new window is created)\\n\\n* Very useful for keeping track of a subset of data in an array/string etc.\\n\\n#### *Example:* \\nWrite a function called maxSubarraySum which accepts an array of integers and a number called n. The function should calculate the maximum sum of n consecutive elements in the array.\\n\\nSample Inputs:\\nmaxSubarraySum([1,2,5,2,8,1,5],2) // 10\\nmaxSubarraySum([1,2,5,2,8,1,5],4) // 17\\nmaxSubarraySum([4,2,1,6],1) // 6\\nmaxSubarraySum([4,2,1,6,2],4) // 13\\nmaxSubarraySum([],4) // null\\n\\n\\n### Standard Solution\\n```javascript\\nfunction maxSubarraySum(arr, num) {\\n  if ( num > arr.length){\\n    return null;\\n  }\\n  var max = -Infinity;\\n  for (let i = 0; i < arr.length - num + 1; i ++){\\n    temp = 0;\\n    for (let j = 0; j < num; j++){\\n      temp += arr[i + j];\\n    }\\n    if (temp > max) {\\n      max = temp;\\n    }\\n  }\\n  return max;\\n}\\n```\\n\\n### Optimized solution\\n```javascript\\nfunction maxSubarraySum(arr, num){\\n  let maxSum = 0;\\n  let tempSum = 0;\\n  if (arr.length < num) return null;\\n  for (let i = 0; i < num; i++) { // Initiated out first slide with num numbers\\n    maxSum += arr[i]; // Store the sum on num array values in maxSum\\n  }\\n  tempSum = maxSum; // Initiate the tempSum with maxSum value\\n  for (let i = num; i < arr.length; i++) { // Iterate from where you left before\\n    tempSum = tempSum - arr[i - num] + arr[i]; // don\'t need to iterate again the num numbers of next slide instead sub the earlier starting value and add next first value.\\n    maxSum = Math.max(maxSum, tempSum); // Calculate the maximum of two values and asign to maxSum\\n  }\\n  return maxSum;\\n}\\n```"},{"id":"/recursion-daily-practicing","metadata":{"permalink":"/yogeshcodes/blog/recursion-daily-practicing","source":"@site/blog/recursion-daily-practicing.md","title":"Recursion in daily programming!","description":"We may use recursion in daily programming without knowing.","date":"2022-07-20T12:48:36.000Z","formattedDate":"July 20, 2022","tags":[],"truncated":false,"authors":[],"prevItem":{"title":"Problem Solving Patterns","permalink":"/yogeshcodes/blog/problem-solving-patterns"},"nextItem":{"title":"Solid Principles with React","permalink":"/yogeshcodes/blog/solid-principles-react"}},"content":"We may use recursion in daily programming without knowing.\\nI will explain what recursion is and where can we use it. Keep reading!\\n\\n## **What is recursion?** \\nIn layman terms, when we doing the same task repeatedly we can call it a recursive task. In programming terms, when a function calls a function itself to do the task and it\'s going iteratively to complete. It\'s called recursion.\\n\\n### Still confused?\\n\\nOkay, take one example.\\n\\n```javascript\\nfunction findCorrectObject(arr, id) {\\n   if(arr[arr.length].id === id) {\\n     return arr[arr.legth];\\n   } else if(arr.length === 0) {\\n     return \\"Not found!\\";\\n   } else {\\n     arr.pop();\\n     findCorrectObject(arr, id);\\n   }\\n}\\nfindCorrectObject([{id: \\"3434343\\", title: \\"title 1\\"}, {id: \\"45454565\\", title: \\"title 2\\"}], \\"3434343\\");\\n```\\n\\nIn this example, we finding the correct element from the array. As you see we called the same function with the required params. This is recursion. It\'ll run till it finds the correct object or the till the array will empty. \\n\\nSimple right?\\n\\n## **Where we can use it?**\\nIn javascript, recursion taking a huge place. In so many scenarios we can use the recursion. Example: JSON.parse / JSON.stringify\\n\\nIf you look inside the code of __deep() in lodash library it uses the same recursion. I\'m telling deep cloning means in javascript if assign an object to a variable it\'ll shallow copy it\'ll not a deep copy. This means when you changed the new object created with the existing one it\'ll also change the existing one. \\n\\nWe can use recursion to solve that problem. \\n\\nHere is the code for deep copy of an object! Don\'t get fear about huge code. I\'ll explain what it actually will do. Read the code carefully!\\n\\n```javascript\\nfunction clone(item) {\\n  if (!item) {\\n    return item;\\n  } // null, undefined values check\\n\\n  var types = [Number, String, Boolean],\\n    result;\\n\\n  // normalizing primitives if someone did new String(\'aaa\'), or new Number(\'444\');\\n  types.forEach(function(type) {\\n    if (item instanceof type) {\\n      result = type(item); // Yeah, we used recursion here! To find the exact primitive\\n    }\\n  });\\n  \\n  // If the result is still undefined. The item should be an Object or Array\\n  if (typeof result == \\"undefined\\") { \\n    if (Object.prototype.toString.call(item) === \\"[object Array]\\") {\\n      result = [];\\n      // If the item is array, we call the same function to deep clone each values. Yes it is recursion.\\n      item.forEach(function(child, index, array) {\\n        result[index] = clone(child);\\n      });\\n    } else if (typeof item == \\"object\\") {\\n      // testing that this is DOM\\n      if (item.nodeType && typeof item.cloneNode == \\"function\\") {\\n        result = item.cloneNode(true);\\n      } else if (!item.prototype) {\\n        // check that this is a literal\\n        if (item instanceof Date) {\\n          result = new Date(item);\\n        } else {\\n          // it is an object literal\\n          result = {};\\n          for (var i in item) {\\n            result[i] = clone(item[i]);\\n          }\\n        }\\n      } else {\\n        // depending what you would like here,\\n        // just keep the reference, or create new object\\n        if (false && item.constructor) {\\n          // would not advice to do that, reason? Read below\\n          result = new item.constructor();\\n        } else {\\n          result = item;\\n        }\\n      }\\n    } else {\\n      result = item;\\n    }\\n  }\\n\\n  return result;\\n}\\n\\nvar copy = clone({\\n  one: {\\n    \\"one-one\\": new String(\\"hello\\"),\\n    \\"one-two\\": [\\"one\\", \\"two\\", true, \\"four\\"]\\n  },\\n  two: document.createElement(\\"div\\"),\\n  three: [\\n    {\\n      name: \\"three-one\\",\\n      number: new Number(\\"100\\"),\\n      obj: new (function() {\\n        this.name = \\"Object test\\";\\n      })()\\n    }\\n  ]\\n});\\n```\\n\\n### **Another Example**\\nIf you think the previous example is too much, here I took one famous problem to explain recursion. \\n```javascript\\nfunction calculateFactorial(num) {\\n  if(num === 1) return 1;\\n  return num * calculateFactorial(num - 1);\\n}\\n\\ncalculateFactorial(5);\\n```\\nIn this function, the calculateFactorial will call a total of 5 times to complete the problem. Whenever the calculateFactorial(num - 1) function call it\'ll create the separate function stack and the previous function will wait till the current function resolves. Likewise, the new function will be called in runtime until it returns 1. \\n\\n\\nI recently used recursion in my project. I currently working with reactJS. So it\'ll better if explain the real-life scenario. We had one problem, the user need to select the children of the parent in the dropdown. And the children might have another child. Likewise the data will grove. I used this [library](https://dowjones.github.io/react-dropdown-tree-select/#/story/with-material-design-styles) to solve the particular problem.\\n\\n![](https://s5.gifyu.com/images/recursion-example.gif)\\n\\nI immensely used recursion inside. Because each object might have another set of object and I need to go through all the phases until I reach the final object without another child. \\n\\nRecursion solving so many problems that loops cannot solve. And also the code will be cleaner and optimized. \\n\\nThanks for reading!!"},{"id":"/solid-principles-react","metadata":{"permalink":"/yogeshcodes/blog/solid-principles-react","source":"@site/blog/solid-principles-react.md","title":"Solid Principles with React","description":"SOLID is an acronym for the first five object-oriented design (OOD) principles by Robert C. Martin (also known as Uncle Bob).","date":"2022-07-20T12:48:36.000Z","formattedDate":"July 20, 2022","tags":[{"label":"solid","permalink":"/yogeshcodes/blog/tags/solid"},{"label":"react","permalink":"/yogeshcodes/blog/tags/react"},{"label":"javascript","permalink":"/yogeshcodes/blog/tags/javascript"},{"label":"best-practices","permalink":"/yogeshcodes/blog/tags/best-practices"}],"truncated":false,"authors":[],"prevItem":{"title":"Recursion in daily programming!","permalink":"/yogeshcodes/blog/recursion-daily-practicing"}},"content":"*SOLID* is an acronym for the first five object-oriented design (OOD) principles by Robert C. Martin (also known as [Uncle Bob](http://en.wikipedia.org/wiki/Robert_Cecil_Martin)).\\n\\n**The SOLID principles are a set of software design principles that teach us how we can structure our functions and classes to be as robust, maintainable and flexible as possible.**\\n\\n### The problem:\\n\\nEarly days of my career I used to write code that solves the problem fast and never cared about code extensibility and reusability or any design problems.\\n\\nI felt like winning at the start but when the codebase grew it becomes a mess. Whenever the user wants a new change to the existing features. It was a nightmare to implement it and push it to production. \\n\\nThe problem never ends there and I was introducing new bugs by making new changes. The struggle was real. \\n\\nI was doing alterations instead of solving the problem for real.\\n\\nAnd then I realised there is a problem which needs to be fixed. Then I did lots of research about how to write clean code. \\n\\nIf you ever face the above problems you\'re not alone. But we\'re going to sort this out. \\n\\n### Solution:\\n\\nThe fundamentals of writing good code are following how other people write code without making the codebase a mess. \\n\\nUncle Bob is an experienced person and faced all the problems we faced in his days. And he defined principles to write good code. The SOLID principles are one of them. \\n\\n### SOLID stands for:\\n\\n- **[S** - Single-responsibility Principle]\\n- **[O** - Open-closed Principle]\\n- **[L** - Liskov Substitution Principle]\\n- **[I** - Interface Segregation Principle]\\n- **[D** - Dependency Inversion Principle]\\n\\n### If you follow SOLID principles, you can:\\n\\n1. Write testable code\\n2. Easily extend the old code and implement new features. \\n3. Make fewer bugs\\n4. Understand the code you wrote a few years ago. \\n\\n## **Single-Responsibility Principle**\\n\\n<aside>\\n\ud83d\udca1 A class should have one and only one reason to change, meaning that a class should have only one task to do.\\n</aside>\\n\\n![Untitled](/images/good-design-bad-design-srp.png)\\n\\nLet\'s try to understand this with the Twitter feed. \\n\\n```jsx\\nconst Home = () => {\\n\\tconst [posts, setPosts] = useState([]);\\n\\t\\n\\tuseEffect(() => {\\n\\t\\tfetch(\'/api/posts\').then(data => setPosts(data))\\n\\t}, []);\\n\\n\\treturn (\\n\\t\\t<div className=\\"home\\">\\n\\t\\t\\t<div className=\\"top-bar\\">\\n\\t\\t\\t\\tHeader....\\n\\t\\t\\t</div>\\n\\t\\t\\t<div className=\\"feed\\">\\n\\t\\t\\t\\t{posts.map(post => (\\n\\t\\t\\t\\t\\t<div>\\n\\t\\t\\t\\t\\t\\t{post.title}\\n\\t\\t\\t\\t\\t</div>\\n\\t\\t\\t\\t))}\\n\\t\\t\\t</div>\\n\\t\\t\\t<div className=\\"footer\\">\\n\\t\\t\\t\\tFooter\\n\\t\\t\\t</div>\\n\\t\\t</div>\\n\\t)\\n}\\n```\\n\\nHere is the Twitter home page and we added header, posts and the footer.  \\n\\nAnd we violated the first principle of SOLID.\\n\\n### What?\\n\\nAs per the single responsibility principle, the class/module should do only one task. But in our case, it\'s doing multiple tasks. \\n\\nFetching the posts, header, footer data. Rendering the header, post, footer. \\n\\n### Let\'s refactor\\n\\nThe solution\\n\\n```jsx\\n// Extracted the Header component from Home\\nconst Header = ({title, description}) => {\\n\\treturn (\\n\\t\\t<div>\\n\\t\\t\\t{title}\\n\\t\\t\\t{description}\\n\\t\\t</div>\\n\\t)\\n}\\n\\n// Extracted the Post component from Home\\nconst Post = ({title, profile}) => {\\n\\treturn (\\n\\t\\t\\n\\t)\\n}\\n\\n// Made custom hook to fetch the posts\\nconst usePosts = () => {\\n\\tconst [posts, setPosts] = useState([]);\\n\\t\\n\\tuseEffect(() => {\\n\\t\\tfetch(\'/api/posts\').then(data => setPosts(data))\\n\\t}, []);\\n\\treturn posts;\\n}\\n\\n// To render the post lists\\nconst PostsList = () => {\\n\\t\\tconst posts = usePosts();\\n}\\n\\nconst Feed = () => {\\n\\treturn (\\n\\t\\t<>\\n\\t\\t\\t<Header />\\n\\t\\t\\t<PostList />\\n\\t\\t</>\\n\\t)\\n\\n}\\n```\\n\\nI reduced LOC for the sake of simplicity. \\n\\nAs you see the code is already improved a lot and is well readable and extensible. \\n\\n## **Open-Closed Principle**\\n\\n<aside>\\n\ud83d\udca1 Objects or entities should be open for extension but closed for modification.\\n\\n</aside>\\n\\n![Untitled](/images/good-design-bad-design-ocp.png)\\n\\nThis means that a class/module should be extendable without modifying the class itself.\\n\\nSoftware systems are designed to allow the behaviour of those systems to be changed by adding new code, rather than changing existing code.\\n\\nLet\'s take a look at the [react-popper](https://popper.js.org/react-popper/) library.  React Popper is a react wrapper over popperjs library. And it is extensively used for positioning the elements. \\n\\nusePopper helps to position the element based on the virtual reference/bounding position\\n\\n```jsx\\nconst [popperElement, setPopperElement] = React.useState(null);\\nconst { styles, attributes } = usePopper(virtualReference, popperElement);\\nreturn (\\n    <div ref={setPopperElement} style={styles.popper} {...attributes.popper}>\\n      Tooltip\\n    </div>\\n);\\n```\\n\\nThe above code will position the tooltip something like below. \\n\\n![Untitled](/images/tooltip-example-solid.png)\\n\\nNow the problem is the element will stick just like this. Even if you scroll the element will not move above or below since it\'s a virtual reference we have to take care of the scrolling events. And we need to let the element move with the document while scrolling.  \\n\\n### Let\'s do it\\n\\n```jsx\\nconst usePopperPosition = ({popperElement, popperContainer}) => {\\n\\tconst { styles, attributes } = usePopper(virtualReference, popperElement);\\n\\t\\n\\tconst updatePosition = useCallback((): any => {\\n    if (isHidden) return;\\n    if (!popperElement) return;\\n\\n    virtualReference.getBoundingClientRect = getBoundingClientRect;\\n    update?.();\\n  }, [getBoundingClientRect, popperElement, update]);\\n\\n  useEffect(() => {\\n    updatePosition();\\n  }, [updatePosition]);\\n\\n  useEffect(() => {\\n    popperContainer?.addEventListener(\'scroll\', updatePosition);\\n    return () => popperContainer?.removeEventListener(\'scroll\', updatePosition);\\n  }, [updatePosition, popperContainer]);\\n\\n  return { ...popperResult, update: updatePosition, styles };\\n}\\n```\\n\\nI know the code is very confusing. Let\'s not dig deeper inside the code for now. \\n\\nBut we extended the usePopper method and created a new hook to add new functionality. \\n\\nYaayy we implemented a new feature without violating the Open-closed principle. \\n\\n## **Liskov Substitution Principle**\\n\\n<aside>\\n\ud83d\udca1 Let q(x) be a property provable about objects of x of type T. Then q(y) should be provable for objects y of type S where S is a subtype of T.\\n</aside>\\n\\n![Untitled](/images/solid-liskov-example.png)\\n\\nThe above image is just for understanding the Liskov principle LOL. \\n\\nThis means that every subclass or derived class should be substitutable for their base or parent class.\\n\\nLiskov is probably the most difficult principle to understand. But not anymore.\\n\\nLet\'s start by implementing Liskov with the classes.\\n\\n```jsx\\nclass Bird {\\n\\tfly() {\\n\\t\\tconsole.log(\'I can fly\');\\n\\t}\\n}\\n\\nclass Duck extends Bird {\\n\\tquack() {\\n\\t\\tconsole.log(\'I can quack\');\\n\\t}\\n}\\n\\nclass Penguin extends Bird {\\n\\t// Here we violating the Liskow principle by affecting the parent class method.\\n\\tfly() {\\n\\t\\tthrow new Error(\'I can\\\\\'t fly\');\\n\\t}\\n\\n\\tswim() {\\n\\t\\tconsole.log(\'I can swim\');\\n\\t}\\n}\\n\\nfunction makeBirdFly(bird) {\\n\\tbird.fly();\\n}\\n\\nconst duck = new Duck();\\nconst penguin = new Penguin();\\n\\nmakeBirdFly(duck);\\nmakeBirdFly(penguin);\\n```\\n\\nIn the Penguin class, we extended the Bird class and modified the fly behaviour and added swim behaviour since the Penguin cannot fly only can swim.\\n\\n### Fixing the problem\\n\\n```jsx\\nclass FlyingBird {\\n\\tfly() {\\n\\t\\tconsole.log(\'I can fly\');\\n\\t}\\n}\\n\\nclass SwimmingBird {\\n\\tswim() {\\n\\t\\tconsole.log(\'I can swim\');\\n\\t}\\n}\\n\\nclass Duck extends FlyingBird {\\n\\tquack() {\\n\\t\\tconsole.log(\'I can quack\');\\n\\t}\\n}\\n\\nclass Penguin extends SwimmingBird {\\n\\n}\\n\\nfunction makeBirdFly(bird) {\\n\\tbird.fly();\\n}\\n\\nfunction makeBirdSwim(bird) {\\n\\tbird.swim();\\n}\\n\\nconst duck = new Duck();\\nconst penguin = new Penguin();\\n\\nmakeBirdFly(duck);\\nmakeBirdSwim(penguin);\\n```\\n\\nWe\'re now fixed the problem by separating the classes. And now we can use Penguin class for the replacement of SwimmingBird class as per the Liskov principle. \\n\\n### React Example\\n\\nWe can follow Liskow while using interfaces in React\\n\\n```jsx\\ninterface SubmitButtonProps extends HTMLAttributes<HTMLButtonElement> {\\n  color: string;\\n}\\n\\nconst SubmitButton = ({ color, ...buttonProps }: SubmitButtonProps) => {\\n  return <button style={{backgroundColor: color}} {...buttonProps} />\\n}\\n```\\n\\nWe implemented SubmitButton by inheriting the button element without violating the Liskov.\\n\\n## **Interface Segregation Principle**\\n\\nA client should never be forced to implement an interface that it doesn\u2019t use. So that the **larger interfaces should be split into smaller ones. By doing so, we can ensure that implementing classes only need to be concerned about the methods that are of interest to them.**\\n\\nWe can follow the interface Segregation while typing the component props. \\n\\nExample:\\n\\nWe\'re going to design the table selection behaviour from notion.\\n\\n![Untitled](/images/solid-interface-segreg-example.png)\\n\\nBad design\\n\\n```jsx\\n// Table selection range from topLeft to bottomRight\\n// with the current selected cell and the cursorCell(if you navigate through the keyboard)\\nexport interface Range {\\n  topLeft: Position;\\n  bottomRight: Position;\\n\\tstartCell: Position | null;\\n  cursorCell: Position | null;\\n}\\n\\n// We coupled everything into single interface\\n// In case you only want the range(topLeft, bottomRight) you have to extend\\n// startCell and cursorCell\\n```\\n\\nGood design\\n\\n```jsx\\nexport interface Range {\\n  topLeft: Position;\\n  bottomRight: Position;\\n}\\n\\nexport interface SelectedPosition {\\n  startCell: Position | null;\\n  cursorCell: Position | null;\\n}\\n\\nexport interface SelectedRange extends Range, SelectedPosition {}\\n\\n// We segregated everything now it\'s easy to use the interfaces as per we need\\n// without any overhead.\\n```\\n\\n**Dependency Inversion Principle**\\n\\n<aside>\\n\ud83d\udca1 Entities must depend on abstractions, not on concretions. It states that the high-level module must not depend on the low-level module, but should depend on abstractions.\\n\\n</aside>\\n\\n*This principle states that we should depend upon abstractions, not concretions.*\\n\\nExample\\n\\n```jsx\\n\\n// Posts component is tightly coupled\\nconst Posts = () => {\\n\\t...\\n\\tasync fetchPosts() {\\n    const posts = await fetch(\'http://api.innofied.com/posts\');\\n    this.setState({posts});\\n  }\\n\\t...\\n\\treturn (\\n\\t\\t<div>\\n\\t\\t\\t{posts.map()}\\n\\t\\t</div>\\n\\t)\\n}\\n```\\n\\n```jsx\\n// The posts component is now closely coupled and depend on absraction\\nconst Posts = ({fetchPosts}) => {\\n\\t...\\n\\treturn (\\n\\t\\t<div>\\n\\t\\t\\t{posts.map()}\\n\\t\\t</div>\\n\\t)\\n}\\n```\\n\\nConclusion:\\n\\nThat\'s it for this article. It\'s not necessary to follow the SOLID strictly while developing React applications. But you can consider it as one of the principles/best practices to make the code cleaner."}]}')}}]);